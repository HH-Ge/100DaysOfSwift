

# 第 3 阶段（Days 26-35）: 技能拓展（项目4-6）

In these next three projects we’re going to develop your SwiftUI skills in new directions, while also giving you chance to practice the fundamentals.

## [百日学 Swift（Day 26）](https://www.hackingwithswift.com/100/swiftui/26) – Project 4, part one（项目 4 ：第 1 部分）

### [1. BetterRest: Introduction](https://www.hackingwithswift.com/books/ios-swiftui/betterrest-introduction)（BetterRest项目简介）

使用 Core ML 技术，尝试实现回归分析，即机器学习的开始。Core ML 是所有 iPhone 都内置的技术。

项目要求：通过向咖啡饮用者提出以下三个问题来帮助他们改善睡眠质量：

（1）他们什么时候想醒来？

（2）他们想要多少个小时的睡眠？

（3）他们每天喝几杯咖啡？

有了这三个值后，我们会将它们输入Core ML，以得到一个告诉我们何时该睡觉的结果。如果您考虑一下，就会有数十亿个可能的答案：所有各种唤醒时间乘以所有睡眠小时数，再乘以全部咖啡量。无疑这个数字是庞大的，但是实际应用中没有必要也不可能获取到所有人的数据，我们只要保证采集样本足够大就好。样本数据可以到 [GitHub](https://github.com/HH-Ge/100DaysOfSwift/tree/master/Projects/D26-28.BetterRest/BetterRest.mlproj/Data%20Sources) 上下载。

先创建项目吧。

### [2. Entering numbers with Stepper](https://www.hackingwithswift.com/books/ios-swiftui/entering-numbers-with-stepper)（使用 Stepper 输入数值）

Stepper （步进器）是用来输入数字的一个组件，有两个按钮`+`和`-`。可以绑定 Int、Double 等多种数据类型，取值范围由类型决定。Stepper 常见的方法有 `onIncrement` 、 `onDecrement` 和 `onEditingChanged`。具体用法如下：

```swift
@State private var sleepAmount = 8.0
var body: some View {
    Stepper(value: $sleepAmount, in: 4...12, step: 0.25){
        Text("\(sleepAmount, specifier: "%.2f") hours")
    }
}
```

参数：

- value：一般是绑定的状态
- in：数字范围
- step：步长

### [3. Selecting dates and times with DatePicker](https://www.hackingwithswift.com/books/ios-swiftui/selecting-dates-and-times-with-datepicker)（使用 DatePicker 选择日期和时间）

DatePicker 是专用的输入日期的组件，可以绑定到 Date 类型的属性上。

```swift
@State private var wakeUp = Date()

var body: some View {
    VStack(spacing: 5) {
        VStack{
            Text("显示标签, 选择时分")
            DatePicker("请选择时间：", selection: $wakeUp, displayedComponents: .hourAndMinute)
        }.font(.headline)
        Divider()
        VStack{
            Text("隐藏标签")
            DatePicker("请选择日期：", selection: $wakeUp).labelsHidden()
        }.font(.headline)
        Divider()
        VStack{
            Text("放入表单 限制为始于现在")
            Form {
                DatePicker("请选择日期和时间：", selection: $wakeUp, in: Date()...)
            }
        }.font(.headline)
    }
}
```

参数：

- 标签：即使设为空字符，如果没有 labelHidden 也会留出空间
- selection：绑定的属性
- displayedComponents：
    - 默认：一天、一小时、一分钟
    - .date：日、月、年
    - .hourAndMinute：小时、分钟
- in：范围，这个和循环里面用的范围差不多，但是数据类型是Date，而不是 Int 或者 Double。因为时间的表达比较复杂，可以先将起止点设为变量，这样好控制。另外，可以只写一边，让 Swift 去推断另一边（循环是不行的，我的理解是，循环不能是无限的，但是时间是无限的，哈哈）

### [4. Working with dates](https://www.hackingwithswift.com/books/ios-swiftui/working-with-dates)（处理日期）

Swift 提供了 `Date` 结构体，其中封装了年、月、日、时、分、秒……等。Date 类型的计算总是要和秒这个单位打交道，特别不符合我们日常的习惯。

Swift 还提供了 `DateComponents` 结构体，可以保存和读取时间的某个特定部分，比如月、分。

Swift 使用 `DAteFormatter` 完成日期`Date`和字符串`String`之间的转换。

这部分内容看着有些晕乎乎的，因为没有深入介绍。文档还没细致看，回头补上吧。

### [5. Training a model with Create ML](https://www.hackingwithswift.com/books/ios-swiftui/training-a-model-with-create-ml)（使用 CreatML 训练模型）

Core ML能够处理各种训练任务，例如识别图像，声音甚至运动。本项目将研究在机器学习中很常见的表格回归，即可以在Create ML上通过类似于电子表格的大量数据找出各种值之间的关系。

机器学习分两个步骤进行：

- 训练模型：计算机查看所有数据以弄清其中各种值之间的关系的过程，对于大型数据，训练时间少则几个小时，甚至可能更长。
- 预测：是在设备上完成的。将训练后的模型提供给 app，App 将在运行的时候使用以前的结果对新数据进行估算。

（1）创建项目

首先创建一个项目，通过 Xcode 菜单并选择`Open Developer Tool> Create ML`打开 Create ML 应用。有很多模板可供选择，向下滚动到底部，选择`Tabular Regressor`，然后点 Next。项目名称输入`BetterRest`，然后再点 Next，选择保存的文件夹，然后点 Create。

（2）向 Create ML 提供训练数据。

要查看的原始统计数据，包含四个值：起床时间，期待睡眠时间，每天喝多少咖啡以及*实际*需要睡眠时间。项目数据保存在`BetterRest.csv`文件中。这是 Create ML 可以使用的逗号分隔值数据集，我们的第一项工作是导入该数据集。

因此，在 Create ML 中，在左侧的导航栏中选择`Model Sources`中的 `BetterRest`。然后在右侧的 `Data Inputs` 中的 `Traning Date`中，单击`Select File`下拉列表，将打开一个文件选择窗口，选择`BetterRest.csv`。

（3）确定目标`Target`和特征`Features`

Target 是希望计算机学习预测的值，Features 是希望计算机检查以预测目标的值。例如，如果选择某人认为需要多少睡眠和实际需要多少睡眠作为特征，可以训练计算机预测他喝了多少咖啡。

下一步是确定目标，这是我们希望计算机学习预测的值，而功能是我们希望计算机检查以预测目标的值。例如，如果我们选择某人认为需要多少睡眠和*实际*需要多少睡眠作为功能，我们可以训练计算机以预测他们喝了多少咖啡。

将 Target 选择为`actualSleep`，表示希望计算机学习如何预测实际需要睡眠时间。然后点 `Select Features...`，然后选择所有三个选项：`wake`，`estimatedSleep`和`coffee`，表示计算机在生成预测时会将所有这三个因素都考虑在内。

（4）选择算法

 `Select Features...`按钮下面的下拉列表用来选择算法，有五个选项：“自动”`Automatic`，“随机森林”`Random Forest`，“增强树”`Boosted Tree`，“决策树”`Decision Tree`和“线性回归”`Linear Regression`。每个人都采用不同的方法来分析数据，尽管这不是一本关于机器学习的书，但我还是想简要解释一下它们的工作。

线性回归是最容易理解的，因为它几乎完全是我们大脑的工作方式。线性回归试图通过将变量视为线性函数的一部分来估计变量之间的关系，例如`applyAlgorithm(var1, var2, var3)`。线性回归的目标是能够在所有数据点上绘制一条直线，其中直线与每个数据点之间的平均距离应尽可能小。

决策树回归形成的树状结构，使我们可以将信息组织为一系列选择。例如：“您是人还是动物？如果你是一个人，你是活着还是死了？如果您还活着，您是年轻还是老？” 依此类推，每次树会根据每个问题的答案而分支，直到最终有了确定的答案。

增强型树回归使用*一系列*决策树来工作，其中每棵树旨在纠正前一棵树中的任何错误。例如，第一个决策树会尽最大的可能去寻找一个好的预测，但是下降了20％。然后，将其传递到第二个决策树以进行进一步细化，然后重复该过程——但这一次，误差降至10％。那进入了第三棵树，误差降低到8％，第四棵树，误差降低到7％。

随机森林与增强树相似，但略有不同：对于增强树，树中的每个决策都可以访问所有可用数据，而对于随机树，每个树只能访问数据的一个子集。

想象一下您正面临一个编码问题并试图提出一个解决方案。如果您向一位同事征求意见，他会根据*他*所了解的为您提供一些想法。如果您再向其他同事征求意见，他们会根据*他们*所了解的为您提供不同的想法。如果您向一百位同事征求意见，那会获得一系列解决方案。

每个同事的背景，教育程度和工作经历都与其他同事不同，因此您会得到一系列建议。但是，如果您将每个人的建议平均化（不管大多数人怎么说，也不管他们是怎么做出决定的），那么您就有最好的机会获得正确的解决方案。

这就是随机森林回归器的工作方式：每个决策树都有自己的数据视图，该视图与其他树不同，并且通过将所有预测结合在一起以形成平均值，您很有可能获得良好的结果。

`Automatic` 选项可以尝试自动选择最佳算法。虽然并不总是正确的，可是会帮我们减少对选项的纠结。这里我们就选这个啦。

（5）训练

一切准备就绪后，单击窗口标题栏中的“Train”按钮。几秒钟后（因为我们的数据量还是很小的）会看到一些结果指标。我们关心的值称为“均方根误差”，您应该获得大约180的值。这意味着该模型平均能够预测建议的准确睡眠时间，而误差仅为180秒或三分钟。

（6）输出

在右上角的`Output`可以看到一个 MLModel 图标，文件大小约为438字节。我的是 555 bytes，大概机器和机器之间略有差异。现在模型已经训练完毕，将图标从 Create ML 拖到桌面上，等下回在代码中使用。

**提示：**如果想尝试使用其他算法训练，单击“Create ML”窗口右下角的“Make a Copy”。

## [百日学 Swift（Day 27）](https://www.hackingwithswift.com/100/swiftui/27) – Project 4, part two（项目 4 ：第 2 部分）

### [1. Building a basic layout](https://www.hackingwithswift.com/books/ios-swiftui/building-a-basic-layout)（创建基本布局）

（1）添加输入控件属性

```swift
@State private var wakeUp = Date()          // 计划起床时间
@State private var sleepAmount = 8.0        // 期待睡眠时长
@State private var coffeeAmount = 1         // 每日饮用咖啡数量
```

（2）搭建 UI 骨架

使用下面的代码替换掉默认的 Hello World 文本视图。

```swift
NavigationView {
    VStack {
        // 计划起床时间
        Text("打算几点起床呢？")
        	.font(.headline)
        DatePicker("Please enter a time", selection: $wakeUp, displayedComponents: .hourAndMinute)
        	.labelsHidden()
        // 预期睡眠时长
        Text("想睡多久呢？")
        	.font(.headline)
        Stepper(value: $sleepAmount, in: 4...12, step: 0.25) {
            Text("\(sleepAmount, specifier: "%g") 小时")
        }
        .padding(.horizontal)
        // 每日饮用咖啡杯数
        Text("每天喝几杯咖啡☕️？")
        	.font(.headline)
        Stepper(value: $coffeeAmount, in: 1...20) {
            Text("\(coffeeAmount) 杯")
        }
        .padding(.horizontal)
    }
}
```

（3）创建按钮和调用方法

- 在 ContentView 中增加方法

```swift
func calculateBedtime() {
}
```

- 给 VStack 增加按钮修饰


```swift
.navigationBarItems(trailing:
    Button(action: calculateBedtime) {
        Text("预计就寝时间")
    }
)
```

这样，界面基本上搭建好了，但是按钮调用的方法暂时因为没有代码而不起作用。

### [2. Connecting SwiftUI to Core ML](https://www.hackingwithswift.com/books/ios-swiftui/connecting-swiftui-to-core-ml)（将 SwiftUI 连接到 Core ML）

（1）导入 Core ML 模型到项目

前面通过 Create ML 已经创建好了模型，并通过 Output 输出到 BetterRest.mlmodel 文件。找到这个文件，拖到 Xcode 中的项目文件夹并改名为 SleepCalculator.mlmodel。这样，Xcode 会自动创建一个名为 SleepCalculator 的类。

（2）补充显示信息用的属性

```swift
@State private var alertTitle = ""          // 对话框标题
@State private var alertMessage = ""        // 对话框内容
@State private var showingAlert = false     // 对话框显示状态
```

（3）完成按钮调用方法

```swift
// 按钮调用方法
func calculateBedtime() {
    let model = SleepCalculator()
    let components = Calendar.current.dateComponents([.hour, .minute], from: wakeUp)    // 读取起床时间的时和分
    let hour = (components.hour ?? 0) * 60 * 60     // 将小时换算成秒
    let minute = (components.minute ?? 0) * 60      // 将分钟换算成秒
    do {
        let prediction = try model.prediction(wake: Double(hour + minute), estimatedSleep: sleepAmount, coffee: Double(coffeeAmount))   // 使用模型预测
        let sleepTime = wakeUp - prediction.actualSleep     // 得出就寝时间
        let formatter = DateFormatter()                     // 使用 DateFormatter 转换显示格式
        formatter.timeStyle = .short
        alertTitle = "合理就寝时间是："
        alertMessage = formatter.string(from: sleepTime)
    } catch {
        // 出错处理
        alertTitle = "出错啦！~"
        alertMessage = "很遗憾，程序发生了错误。"
    }
    showingAlert = true		// 无论是否出错，总是显示对话框
}
```

（4）给 VStack 增加 alert 修饰，这样在 calculateBedtime 方法调用结束时，由于 showingAlert 总是设为 true，所以会向用户显示信息。

```swift
.alert(isPresented: $showingAlert) {
    Alert(title: Text(alertTitle), message: Text(alertMessage), dismissButton: .default(Text("好")))
}
```

应该说，程序总体设计告一段落了，下面做一些小的调整。

### [3. Cleaning up the user interface](https://www.hackingwithswift.com/books/ios-swiftui/cleaning-up-the-user-interface)（整理界面）

（1）缩小起床时间的选择范围

绝大多数用户基本上没有夜班需求，所以将起床时间默认设在早上 6 点到 8 点之间会使更多的用户感到方便。可以给添加一个默认起床时间的属性：

```swift
var defaultWakeTime: Date {
    var components = DateComponents()
    components.hour = 7
    components.minute = 0
    return Calendar.current.date(from: components) ?? Date()
}
```

这是个计算属性，使用了 DateComponents 来构建了一个 Date，默认是早上7点，这样就能满足了大部分人需要将起床时间设定为早上 6 点到 8 点之间的需求。然后我们把这个属性作为 wakeUp 的默认值。

```swift
@State private var wakeUp = defaultWakeTime
```

结果会是编译失败，错误是：`Cannot use instance member 'defaultWakeTime' within property initializer;` 这是因为 Swift 不允许这样让一个属性直接使用另一个属性，因为不知道先创建了哪个属性。解决方法是将 defaultWakeTime 设为静态变量，即增加 static 关键字在 var 的前面。

```swift
static var defaultWakeTime: Date {
```

（2）界面调整

首先可以将整个的 VStack 换成 Form，这样使得整个视图成为一个表单，排版比现在这样规整一些。

然后对于每个输入项目有两种方式调整：

- 使用 Section 包裹，去掉 Text 视图，直接在 Section 的 Title 中定义文本（我单独写在了 SectionView.swift 中了）
- 使用 VStack 包裹，设定对齐方式和间距

## [百日学 Swift（Day 28）](https://www.hackingwithswift.com/100/swiftui/28) – Project 4, part three（项目 4 ：第 3 部分）

### 1. 项目盘点

- 新的组件：DatePicker， Stepper，navigationBarItems
- 新的结构体：Date，DateComponents，DateFormatter
- Create ML 和 Core ML
- 不允许属性直接引用属性，如果要引用，需要先设为 static
- 复习练习容器组件和修饰符

> 我发现了个问题，就是在`.alert`修饰器中，对显示的标题或者内容的 Text 加字号修饰貌似无效。

### 2. 挑战

- 去掉按钮，始终显示结果
- 现在这个模型得到的结果是在同样的起床时间预设下，咖啡杯数越多，就寝时间越早……不明白其中的道理。尝试修改模型，研究一下咖啡的作用，即输入期待起床和就寝时间看看和每天饮用咖啡的杯数是啥关系。

## [[百日学 Swift（Day 29）](https://www.hackingwithswift.com/100/swiftui/29) – Project 5, part one（项目 5 ：第 1 部分）

### 1. [Word Scramble: Introduction](https://www.hackingwithswift.com/books/ios-swiftui/word-scramble-introduction)（猜单词项目）

本项目依旧是个小游戏，给玩家一个单词，如 alarming，然后玩家使用单词提供的字母重新组合新的单词，如 ring，mar 等。

我们会应用 List，onAppear()，Bundle，fatalError() 等，然后继续练习前面用过的 @State，Alert，NavigationView 等组件和知识。

现在创建一个新的 Single View App 项目，名字为 WordScramble。到 GitHub 上下载该项目需要的 start.txt 文件。

### 2. [Introducing List, your best friend](https://www.hackingwithswift.com/books/ios-swiftui/introducing-list-your-best-friend)（List 组件）

List 提供可滚动的数据列表，而 Form 实际上是特殊的 List 而已。List 用来展示数据而非输入数据。最常见的写法是：

```swift
List {
    Text("Hello World")
    Text("Hello World")
    Text("Hello World")
}
```

还可以使用循环展示动态内容

```swift
List {
    ForEach(0..<5) {
        Text("Dynamic row \($0)")
    }
}
```

也可以混用

```swift
List {
    Text("Static row 1")
    Text("Static row 2")

    ForEach(0..<5) {
        Text("Dynamic row \($0)")
    }

    Text("Static row 3")
    Text("Static row 4")
}
```

如果再加上分节展示就是

```swift
List {
    Section(header: Text("Section 1")) {
        Text("Static row 1")
        Text("Static row 2")
    }

    Section(header: Text("Section 2")) {
        ForEach(0..<5) {
            Text("Dynamic row \($0)")
        }
    }

    Section(header: Text("Section 3")) {
        Text("Static row 3")
        Text("Static row 4")
    }
}
```

在处理数据是，SwiftUI 需要知道每一行的 id，来保证单独对这行数据进行操作。但对于某个数组而言，每个元素本身就可以成为自己的标识符，从而可以替代 id 的作用。这时候可以使用 `id: \.self`

```swift
List {
    ForEach(people, id: \.self) {
        Text($0)
    }
}
```

### 3. [Loading resources from your app bundle](https://www.hackingwithswift.com/books/ios-swiftui/loading-resources-from-your-app-bundle)（从 app bundle 中获取资源）

使用`Image`视图时，SwiftUI会知道在应用程序的资产目录中查找插图，它甚至会自动调整插图，以便为当前的屏幕分辨率加载正确的图片——这就是我们之前查看的@ 2x和@ 3x内容。

对于其他类型的数据，例如文本文件或具有特定的数据格式（例如XML或JSON）文件类型，则需要另外的方法调用。

Xcode 构建应用时，会创建一个称为`bundle`的东西。 允许系统将一个应用程序的所有文件存储在一个地方，就是我们编写的 Swift 代码编译后的那个二进制代码，所有插图，根据需要提供的任何其他文件，Info.plist文件等等，全部集中在这个地方。

将来，随着技能的提高，我们将学习如何在单个应用程序中实际包含多个捆绑软件，包括Siri 扩展，iMessage应用程序，watchOS 应用程序等内容，所有这些都是在单个 iOS 应用程序捆绑中，称为 main bundle。

在捆绑包中查找其中的文件使用了一种称为`URL`的新数据类型，URL不仅可以存储网址，还可以存储文件的位置。

如果要读取主应用程序捆绑包中文件的 URL，要使用`Bundle.main.url()`。如果该文件存在，则会返回给我们，否则返回`nil`，所以`URL`是可选的。所以需要像这样解包：

```swift
if let fileURL = Bundle.main.url(forResource: "some-file", withExtension: "txt") {
    // we found the file in our bundle!
}
```

应用程序位于沙箱中，所以不应该尝试在其外部读取`URL`里面的内容。

有了URL 后，我们可以使用特殊的初始化程序`String(contentsOf:)`将其加载到字符串中。我们给它一个文件 URL，如果可以加载，它将发送一个包含该文件内容的字符串。如果*无法*加载，则会引发错误，因此需要使用`try`或`try?`类似方式调用它：

```swift
if let fileContents = try? String(contentsOf: fileURL) {
    // we loaded the file into a string!
}
```

一旦有了文件的内容，就可以随心所欲地处理了，因为它只是一个常规字符串。

### 4. [Working with strings](https://www.hackingwithswift.com/books/ios-swiftui/working-with-strings)（使用字符串）

iOS为我们提供了一些功能非常强大的API，用于处理字符串，包括将它们拆分为数组，删除空格甚至检查拼写的能力。

#### （1）拆分字符串为字符串数组：`components(separatedBy:)`方法

在此应用程序中，我们将从应用程序包中加载一个文件，该文件包含10,000多个8个字母的单词，每个单词均可用于启动游戏。这些单词每行存储一个，所以我们真正想要的是将字符串拆分成字符串数组，以便我们可以随机选择一个。

Swift提供了`components(separatedBy:)`方法，可以利用分隔符将单个字符串转换为字符串数组。例如，下面的代码将创建数组`["a1", "b2", "c3"]`：

```swift
let input = "a1 b2 c3"	// 原例子没有数字，但我怕有童鞋会误解为转换成单个字符
let strings = input.components(separatedBy: " ")
```

如果有一个字符串，单词之间用换行符`\n`分隔，因此要将其转换为字符串数组，需要对此进行拆分。

```swift
let input = """
            好雨知时节
            当春乃发生
            随风潜入夜
			润物细无声
            """
let strings = input.components(separatedBy: "\n")
```

无论我们分割了什么字符串，结果都是一个字符串数组。可以通过索引来读取数组中单个值，例如`strings[0]`或`strings[2]`，Swift 还提供了另一个有用的选择：该`randomElement()`方法从数组中返回一个随机项。

如果 letter 是从某个字符串分解得到的字母数组，下面的代码将从数组中读取一个随机字母：

```swift
let letter = letters.randomElement()
```

Swift 并不了解要分解的字符串里面包括什么内容（也许我们试图拆分一个空字符串），所以`randomElement()`方法返回一个可选字符串，我们必须与nil合并解包。

#### （2）删除首尾空白：`trimmingCharacters(in:)`方法

另一个有用的方法是`trimmingCharacters(in:)`，会从字符串的开头和结尾删除某些种类的字符。其中使用了一种称为`CharacterSet`的新类型，但是大多数时候我们想要干的是删除空格和换行符——指的是同时包含空格，制表符和换行符。

由于这太常见了，所以被内置在`CharacterSet`结构中，这样就可以在字符串的开头和结尾处删除所有*空白*，如下所示：

```swift
let trimmed = letter?.trimmingCharacters(in: .whitespacesAndNewlines)
```

#### （3）检查拼写错误：`UITextChecker`类

检查拼写错误的单词的功能通过`UITextChecker`类提供。类名中的“ UI”有两个附加含义：

- 此类来自 UIKit 。但是，这并不意味着正在加载所有旧的用户界面框架。实际上这是通过SwiftUI自动获取的。
- 它是使用 Apple 的较旧语言 Objective-C 编写的。我们不需要编写 Objective-C 来使用它，但是对于Swift用户来说，API有点笨拙。

检查字符串中拼写错误的单词总共需要四个步骤。首先，我们创建一个要检查的单词以及一个可以用来检查该字符串的`UITextChecker`实例：

```swift
let word = "swift"
let checker = UITextChecker()
```

其次，需要告诉检查器要检查多少字符串，是用户选择的文本，还是整个文档。

但是，这里有个陷阱：Swift 使用非常聪明，非常先进的字符串处理方式，从而使其可以使用复杂字符（例如表情符号）的方式与使用英语字母的方式完全相同。然而，Objective-C中并*没有*使用存储字母的这种方法，这意味着我们需要让 Swift 使用所有字符的整个长度去创建一个 Objective-C 字符串范围 `NSRange`：

```swift
let range = NSRange(location: 0, length: word.utf16.count)
```

UTF-16 是所谓的*字符编码* ——一种将字母存储在字符串中的方法。我们在这里使用它，以便 Objective-C 可以了解 Swift 的字符串是如何存储的；对于我们来说，这是一种很好的桥接格式。

第三，我们可以要求文本检查器报告在单词中发现任何拼写错误的地方，传递要检查的范围，在该范围内开始的位置（因此我们可以执行“查找下一个”之类的操作），是否应该换行一旦到达末尾，以及字典使用哪种语言：

```swift
let misspelledRange = checker.rangeOfMisspelledWord(in: word, range: range, startingAt: 0, wrap: false, language: "en")
```

这会返回另一个 NSRange，告诉我们在哪里发现了拼写错误。即使那样，这里仍然存在一个复杂性：Objective-C 没有任何可选概念，因此只能依赖特殊值来表示丢失的数据。如果Objective-C范围返回为空（即，因为字符串正确拼写而没有拼写错误），那么我们将返回特殊值`NSNotFound`。

因此，我们可以检查拼写结果，看是否有这样的错误：

```swift
let allGood = misspelledRange.location == NSNotFound
```

好的，API探索就足够了，让我们进入我们的实际项目…

## [百日学 Swift（Day 30）](https://www.hackingwithswift.com/100/swiftui/30) – Project 5, part two（项目 5 ：第 2 部分）

### [1. Adding to a list of words](https://www.hackingwithswift.com/books/ios-swiftui/adding-to-a-list-of-words)（添加单词到列表）

该应用程序的用户界面将由三个主要的视图组成：一个`NavigationView`显示正在拼写的单词，一个`TextField`可以输入一个答案的位置以及一个`List`显示之前输入的所有单词的视图。

现在，每次用户在文本字段中输入单词时，都会自动将其添加到已用单词列表中。但是，稍后，我们将添加一些验证，以确保该词以前从未使用过，实际上可以从给出的词根中产生，并且是真实词，而不仅仅是一些随机字母。

（1）添加属性

需要一个已经使用过的单词数组，一个根词来为其拼写其他单词，以及一个可以绑定到文本字段的字符串。因此，添加以下三个属性：

```swift
@State private var usedWords = [String]()	// 使用过的单词数组
@State private var rootWord = ""			// 词根
@State private var newWord = ""				// 用户输入的词
```

（2）视图主体

一个`NavigationView`带有`rootWord`标题，然后`VStack`带有一个文本字段和一个列表：

```swift
var body: some View {
    NavigationView {
        VStack {
            TextField("请输入", text: $newWord)

            List(usedWords, id: \.self) {
                Text($0)
            }
        }
        .navigationBarTitle(rootWord)
    }
}
```

通过将`usedWords`直接给到`List`，数组中的每一个词占一行，词语本身就是唯一标识。如果`usedWords`中有很多重复项，会有一些问题，但是很快我们将不允许这样做，所以这不是问题。

（3）修饰 TextField

现在运行程序，在导航栏或列表旁边甚至看不到 TextField。可以通过使用`textFieldStyle()`修饰器在其边缘周围绘制浅灰色边框来解决，再加上一些 `padding()`，看起来就更舒服了些：

```swift
.textFieldStyle(RoundedBorderTextFieldStyle())
.padding()
```

（4）编写添加单词到列表的方法

为了解决这个问题，编写一个新方法`addNewWord()`，该方法将：

- 小写`newWord`并删除所有空格
- 检查它至少有1个字符，否则退出
- 将该单词插入`usedWords`数组中的位置0
- 设置`newWord`为空字符串

稍后，我们将在第2步和第3步之间添加一些额外的验证：

```swift
func addNewWord() {
    // 将单词变为小写，去掉空格
    let answer = newWord.lowercased().trimmingCharacters(in: .whitespacesAndNewlines)

    // 如果是空字符串就退出
    guard answer.count > 0 else {
        return
    }

    // 待编写的校验单词的代码

    // 将输入的单词加入的数组第一个，保证在列表的第一行显示
    usedWords.insert(answer, at: 0)
    // 清空输入框
    newWord = ""
}
```

（5）调用 addNewWord 方法

如果想在用户按下键盘上的return时调用`addNewWord()`，可以通过为文本字段提供*on commit*闭包来实现。这是个尾随闭包。由于闭包的签名（它需要接受的参数及其返回类型）与`addNewWord()`方法完全匹配，因此我们可以直接将其传递：

```swift
TextField("Enter your word", text: $newWord, onCommit: addNewWord)
```

现在运行程序，可以在文本字段中键入单词，按回车键，然后看到它们出现在列表中。

（6）修改 TextField 修饰

`addNewWord()`中会将用户输入的单词转换为小写和去掉空格，这意味着用户不能添加"`" car"`，`"Car"`和`"CAR"`。但是，该文本字段会自动将用户键入的首字母大写，因此，当输入`"Car"`时，他们在列表中看到的是`"car"`。

为了解决这个问题，可以在 TextField 上使用另一个修饰器禁用文本字段的大写`autocapitalization()`：

```swift
.autocapitalization(.none)
```

（7）添加单词长度

SF Symbols 提供从0到50的圆圈数字，所有数字均使用“ x.circle.fill”格式命名，如`1.circle.fill`，`20.circle.fill`。可以用来显示文本旁边每个单词的长度。

如果在`List`的行内使用第二个视图，SwiftUI 将自动创建一个隐式水平堆栈，以便该行中的所有内容并排放置。所以直接在列表中添加`Image(systemName:)`就可以了：

```swift
List(usedWords, id: \.self) {
    Image(systemName: "\($0.count).circle")
    Text($0)
}
```

如果现在运行该应用程序，将会看到可以在文本字段中键入单词，按回车键，然后看到它们滑入列表，并且其长度图标在侧面。真挺好！

### [2. Running code when our app launches](https://www.hackingwithswift.com/books/ios-swiftui/running-code-when-our-app-launches)（启动应用时运行代码）

（1）准备单词表

Xcode 构建 iOS 项目时，会将编译后的程序，Info.plist 文件，资产目录和任何其他资产放入一个名为*bundle*的目录中，然后为该捆绑包命名为 YourAppName.app 。iOS 和Apple 的其他平台会自动识别此“`.app`扩展名，因此，如果在 macOS 上双击类似Notes.app 之类的文件，系统知道要在捆绑软件中启动该程序。

项目中包含一个名为“ start.txt”的文件，里面有10,000多个八个字母的单词，这些单词将随机选择供玩家使用。该文件可以从 GitHub下载，下载后将start.txt拖入项目中。

（2）编写游戏启动方法 startGame()

我们已经定义了一个名为`rootWord`的属性，其中将包含玩家所使用的进行拼写的单词。现在需要编写一个新方法`startGame()`，该方法将：

- 在捆绑包中找到start.txt
- 加载到字符串中
- 将该字符串拆分为字符串数组，每个元素为一个单词
- 从那里选择一个随机词分配给`rootWord`，如果数组为空，则使用明智的默认值。

每一个任务都对应于一行代码，但是有一个不同之处：如果无法在应用程序包中找到start.txt，或者可以*找到*但无法*加载*它，该怎么办？在这种情况下，会遇到一个严重的问题，因为应用程序确实坏了，比如忘记了以某种方式包含文件（在这种情况下游戏无法正常工作），或者包含了该文件，但由于某些原因 iOS 拒绝读取（在这种情况下，游戏将无法正常工作，并且应用程序也已损坏）。

对于这些问题，最好是能立即终止并给出问题的原因，而不是让应用程序始终处于崩溃状态。Swift 提供了一个名为`fatalError()`的函数，该函数可以使我们真正清楚地发现问题。当调用`fatalError()`时，总是会*无条件导致应用程序崩溃*。这对我们来说很重要，看一下代码和注释：

```swift
func startGame() {
    // 在应用的 bundle 中找到 start.txt 的 URL
    if let startWordsURL = Bundle.main.url(forResource: "start", withExtension: "txt") {
        // 2. 将 start.txt 赋值给字符串变量 startWords
        if let startWords = try? String(contentsOf: startWordsURL) {
            // 3. 使用换行符将字符串变量分割为字符串数组
            let allWords = startWords.components(separatedBy: "\n")

            // 4. 随机选择一个元素作为词根，默认为 nothing
            rootWord = allWords.randomElement() ?? "nothing"

            // 如果所有一切都正常，就返回（退出方法）
            return
        }
    }

    // 如果发生了问题，调用 fatalError 函数
    fatalError("Could not load start.txt from bundle.")
}
```

（3）调用 startGame()

现在，我们有了一种为游戏加载所有内容的方法，我们需要在显示视图时实际调用该东西。

SwiftUI为我们提供了一个专用的视图修饰器 onAppear，用于在显示视图时运行闭包，可以在`navigationBarTitle()`后面添加此修饰器它来调用`startGame()`：

```swift
.onAppear(perform: startGame)
```

现在运行游戏，则应该在导航视图的顶部看到一个随机的八个字母的单词。但是玩家仍然可以输入任何单词，包括和词根无关的。让我们接下来修复该问题...

### [3. Validating words with UITextChecker](https://www.hackingwithswift.com/books/ios-swiftui/validating-words-with-uitextchecker)（使用 UITextChecker 检查单词）

现在需要确保用户不能输入无效的单词。我们将以四种小方法实现，每种方法仅执行一次检查：

- 输入的单词是第一次输入
- 输入的单词的字母组合来源于词根（不可能从 nothing 中输入 car）
- 输入的单词是个真实的词

呃，这明明只有*三种*方法——这是因为第四个方法将使显示错误消息更加容易。

（1）isOriginal 方法

好吧，让我们从第一个方法开始：它将接受一个字符串作为其唯一参数，并根据该单词是否被使用过而返回 true 或 false。我们已经有了一个`usedWords`数组，因此我们可以将单词传递给数组的`contains()`方法并将结果发送回：

```swift
func isOriginal(word: String) -> Bool {
    !usedWords.contains(word)
}
```

搞定一个了！

（2）isPossible 方法

下一个比较棘手：如何检查是否可以从另一个随机单词的字母中选出一个随机单词？

有两种方法可以解决此问题，但最简单的方法是：如果创建根单词的可变副本，则可以循环遍历用户输入单词的每个字母，以查看该字母是否存在于副本中。如果是这样，将其从副本中删除（因此不能再次使用），然后继续。如果整个循环都没有遇到找不到的问题，说明该单词就是从词根里面来的，而一旦遇到就返回false。

因此，这是我们的第二个方法：

```swift
func isPossible(word: String) -> Bool {
    var tempWord = rootWord		// 复制词根
	// 遍历输入的单词
    for letter in word {
        if let pos = tempWord.firstIndex(of: letter) {
            // 如果字母在词根中找到，在词根中移除掉这个字母
            tempWord.remove(at: pos)
        } else {
            // 如果没找到，返回 false
            return false
        }
    }

    return true
}
```

（3）isReal 方法

最终的方法比较难，因为我们需要使用 UIKit 中的`UITextChecker`。为了将Swift字符串安全地桥接到 Objective-C 字符串，需要创建一个使用 UTF-16 计数的 Swift 字符串`NSRange`实例。看起来这比较麻烦，但是恐怕在 Apple 清理好这些API之前这是不可避免的。

因此，我们的最后一个方法将创建`UITextChecker`实例，该实例负责扫描字符串中拼写错误的单词。再创建一个`NSRange`来扫描字符串的整个长度，然后文本检查器调用`rangeOfMisspelledWord()`查找错误的单词，会返回*另一个* `NSRange`告诉我们在哪里找到了拼写错误的单词，但是如果单词正确，则该范围的位置将是特殊值`NSNotFound`。代码如下：

```swift
func isReal(word: String) -> Bool {
    let checker = UITextChecker()
    let range = NSRange(location: 0, length: word.utf16.count)
    let misspelledRange = checker.rangeOfMisspelledWord(in: word, range: range, startingAt: 0, wrap: false, language: "en")

    return misspelledRange.location == NSNotFound
}
```

（4）第 4 个方法：wordError

在使用这三个功能之前，可以添加几个属性来控制错误警报的内容：

```swift
@State private var errorTitle = ""
@State private var errorMessage = ""
@State private var showingError = false
```

现在，可以添加一个方法，根据接收到的参数设置标题和消息，然后将`showingError`布尔值翻转为 true：

```swift
func wordError(title: String, message: String) {
    errorTitle = title
    errorMessage = message
    showingError = true
}
```

然后，我们可以通过在`alert()`下面添加一个修饰器将它们直接传递给 `.onAppear()`：

```swift
.alert(isPresented: $showingError) {
    Alert(title: Text(errorTitle), message: Text(errorMessage), dismissButton: .default(Text("好")))
}
```

（5）在`addNewWord()`中用以下内容替换`// 待编写的校验单词的代码`注释：

```swift
guard isOriginal(word: answer) else {
    wordError(title: "这个单词已经输入过了", message: "请输入一个没用过的单词")
    return
}

guard isPossible(word: answer) else {
    let title = String("这个单词不是从 \(rootWord) 来的")
    let message = String("只能在 \(rootWord) 中选择字母，每个字母只能选择一次")
    wordError(title: title, message: message)
    return
}

guard isReal(word: answer) else {
    wordError(title: "输入的单词没有意义", message: "请输入拼写正确的单词")
    return
}
```

如果现在运行程序，会发现尝试重复的单词，无法从根词中拼出的单词和乱七八糟的词都不起作用了。

## [百日学 Swift（Day 31）](https://www.hackingwithswift.com/100/swiftui/31) – Project 5, part three（项目 5 ：第 3 部分）

### 1. 项目盘点

- List 组件
- onAppear 修饰器
- Bundle 的概念和 fatalError() 的应用
- UITextChecker、NSRange 的使用

### 2. 挑战

- 输入单词长度应该大于等于 3
- 增加游戏开始按钮
- 增加得分（猜中单词数量），在不同的分数给不同的警告。
- 增加规则说明

> 项目的源码可以到 [GitHub](https://github.com/HH-Ge/100DaysOfSwift/tree/master/Projects/D29-31.WordScramble) 上查看。









[Day 32](https://www.hackingwithswift.com/100/swiftui/32) – Project 6, part one

[Day 33](https://www.hackingwithswift.com/100/swiftui/33) – Project 6, part two

[Day 34](https://www.hackingwithswift.com/100/swiftui/34) – Project 6, part three



