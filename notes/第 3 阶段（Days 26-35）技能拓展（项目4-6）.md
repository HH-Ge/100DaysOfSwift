

# 第 3 阶段（Days 26-35）: 技能拓展（项目4-6）

In these next three projects we’re going to develop your SwiftUI skills in new directions, while also giving you chance to practice the fundamentals.

## [百日学 Swift（Day 26）](https://www.hackingwithswift.com/100/swiftui/26) – Project 4, part one（项目 4 ：第 1 部分）

### [1. BetterRest: Introduction](https://www.hackingwithswift.com/books/ios-swiftui/betterrest-introduction)（BetterRest项目简介）

使用 Core ML 技术，尝试实现回归分析，即机器学习的开始。Core ML 是所有 iPhone 都内置的技术。

项目要求：通过向咖啡饮用者提出以下三个问题来帮助他们改善睡眠质量：

（1）他们什么时候想醒来？

（2）他们想要多少个小时的睡眠？

（3）他们每天喝几杯咖啡？

有了这三个值后，我们会将它们输入Core ML，以得到一个告诉我们何时该睡觉的结果。如果您考虑一下，就会有数十亿个可能的答案：所有各种唤醒时间乘以所有睡眠小时数，再乘以全部咖啡量。无疑这个数字是庞大的，但是实际应用中没有必要也不可能获取到所有人的数据，我们只要保证采集样本足够大就好。样本数据可以到 [GitHub](https://github.com/HH-Ge/100DaysOfSwift/tree/master/Projects/D26-28.BetterRest/BetterRest.mlproj/Data%20Sources) 上下载。

先创建项目吧。

### [2. Entering numbers with Stepper](https://www.hackingwithswift.com/books/ios-swiftui/entering-numbers-with-stepper)（使用 Stepper 输入数值）

Stepper （步进器）是用来输入数字的一个组件，有两个按钮`+`和`-`。可以绑定 Int、Double 等多种数据类型，取值范围由类型决定。Stepper 常见的方法有 `onIncrement` 、 `onDecrement` 和 `onEditingChanged`。具体用法如下：

```swift
@State private var sleepAmount = 8.0
var body: some View {
    Stepper(value: $sleepAmount, in: 4...12, step: 0.25){
        Text("\(sleepAmount, specifier: "%.2f") hours")
    }
}
```

参数：

- value：一般是绑定的状态
- in：数字范围
- step：步长

### [3. Selecting dates and times with DatePicker](https://www.hackingwithswift.com/books/ios-swiftui/selecting-dates-and-times-with-datepicker)（使用 DatePicker 选择日期和时间）

DatePicker 是专用的输入日期的组件，可以绑定到 Date 类型的属性上。

```swift
@State private var wakeUp = Date()

var body: some View {
    VStack(spacing: 5) {
        VStack{
            Text("显示标签, 选择时分")
            DatePicker("请选择时间：", selection: $wakeUp, displayedComponents: .hourAndMinute)
        }.font(.headline)
        Divider()
        VStack{
            Text("隐藏标签")
            DatePicker("请选择日期：", selection: $wakeUp).labelsHidden()
        }.font(.headline)
        Divider()
        VStack{
            Text("放入表单 限制为始于现在")
            Form {
                DatePicker("请选择日期和时间：", selection: $wakeUp, in: Date()...)
            }
        }.font(.headline)
    }
}
```

参数：

- 标签：即使设为空字符，如果没有 labelHidden 也会留出空间
- selection：绑定的属性
- displayedComponents：
    - 默认：一天、一小时、一分钟
    - .date：日、月、年
    - .hourAndMinute：小时、分钟
- in：范围，这个和循环里面用的范围差不多，但是数据类型是Date，而不是 Int 或者 Double。因为时间的表达比较复杂，可以先将起止点设为变量，这样好控制。另外，可以只写一边，让 Swift 去推断另一边（循环是不行的，我的理解是，循环不能是无限的，但是时间是无限的，哈哈）

### [4. Working with dates](https://www.hackingwithswift.com/books/ios-swiftui/working-with-dates)（处理日期）

Swift 提供了 `Date` 结构体，其中封装了年、月、日、时、分、秒……等。Date 类型的计算总是要和秒这个单位打交道，特别不符合我们日常的习惯。

Swift 还提供了 `DateComponents` 结构体，可以保存和读取时间的某个特定部分，比如月、分。

Swift 使用 `DAteFormatter` 完成日期`Date`和字符串`String`之间的转换。

这部分内容看着有些晕乎乎的，因为没有深入介绍。文档还没细致看，回头补上吧。

### [5. Training a model with Create ML](https://www.hackingwithswift.com/books/ios-swiftui/training-a-model-with-create-ml)（使用 CreatML 训练模型）

Core ML能够处理各种训练任务，例如识别图像，声音甚至运动。本项目将研究在机器学习中很常见的表格回归，即可以在Create ML上通过类似于电子表格的大量数据找出各种值之间的关系。

机器学习分两个步骤进行：

- 训练模型：计算机查看所有数据以弄清其中各种值之间的关系的过程，对于大型数据，训练时间少则几个小时，甚至可能更长。
- 预测：是在设备上完成的。将训练后的模型提供给 app，App 将在运行的时候使用以前的结果对新数据进行估算。

（1）创建项目

首先创建一个项目，通过 Xcode 菜单并选择`Open Developer Tool> Create ML`打开 Create ML 应用。有很多模板可供选择，向下滚动到底部，选择`Tabular Regressor`，然后点 Next。项目名称输入`BetterRest`，然后再点 Next，选择保存的文件夹，然后点 Create。

（2）向 Create ML 提供训练数据。

要查看的原始统计数据，包含四个值：起床时间，期待睡眠时间，每天喝多少咖啡以及*实际*需要睡眠时间。项目数据保存在`BetterRest.csv`文件中。这是 Create ML 可以使用的逗号分隔值数据集，我们的第一项工作是导入该数据集。

因此，在 Create ML 中，在左侧的导航栏中选择`Model Sources`中的 `BetterRest`。然后在右侧的 `Data Inputs` 中的 `Traning Date`中，单击`Select File`下拉列表，将打开一个文件选择窗口，选择`BetterRest.csv`。

（3）确定目标`Target`和特征`Features`

Target 是希望计算机学习预测的值，Features 是希望计算机检查以预测目标的值。例如，如果选择某人认为需要多少睡眠和实际需要多少睡眠作为特征，可以训练计算机预测他喝了多少咖啡。

下一步是确定目标，这是我们希望计算机学习预测的值，而功能是我们希望计算机检查以预测目标的值。例如，如果我们选择某人认为需要多少睡眠和*实际*需要多少睡眠作为功能，我们可以训练计算机以预测他们喝了多少咖啡。

将 Target 选择为`actualSleep`，表示希望计算机学习如何预测实际需要睡眠时间。然后点 `Select Features...`，然后选择所有三个选项：`wake`，`estimatedSleep`和`coffee`，表示计算机在生成预测时会将所有这三个因素都考虑在内。

（4）选择算法

 `Select Features...`按钮下面的下拉列表用来选择算法，有五个选项：“自动”`Automatic`，“随机森林”`Random Forest`，“增强树”`Boosted Tree`，“决策树”`Decision Tree`和“线性回归”`Linear Regression`。每个人都采用不同的方法来分析数据，尽管这不是一本关于机器学习的书，但我还是想简要解释一下它们的工作。

线性回归是最容易理解的，因为它几乎完全是我们大脑的工作方式。线性回归试图通过将变量视为线性函数的一部分来估计变量之间的关系，例如`applyAlgorithm(var1, var2, var3)`。线性回归的目标是能够在所有数据点上绘制一条直线，其中直线与每个数据点之间的平均距离应尽可能小。

决策树回归形成的树状结构，使我们可以将信息组织为一系列选择。例如：“您是人还是动物？如果你是一个人，你是活着还是死了？如果您还活着，您是年轻还是老？” 依此类推，每次树会根据每个问题的答案而分支，直到最终有了确定的答案。

增强型树回归使用*一系列*决策树来工作，其中每棵树旨在纠正前一棵树中的任何错误。例如，第一个决策树会尽最大的可能去寻找一个好的预测，但是下降了20％。然后，将其传递到第二个决策树以进行进一步细化，然后重复该过程——但这一次，误差降至10％。那进入了第三棵树，误差降低到8％，第四棵树，误差降低到7％。

随机森林与增强树相似，但略有不同：对于增强树，树中的每个决策都可以访问所有可用数据，而对于随机树，每个树只能访问数据的一个子集。

想象一下您正面临一个编码问题并试图提出一个解决方案。如果您向一位同事征求意见，他会根据*他*所了解的为您提供一些想法。如果您再向其他同事征求意见，他们会根据*他们*所了解的为您提供不同的想法。如果您向一百位同事征求意见，那会获得一系列解决方案。

每个同事的背景，教育程度和工作经历都与其他同事不同，因此您会得到一系列建议。但是，如果您将每个人的建议平均化（不管大多数人怎么说，也不管他们是怎么做出决定的），那么您就有最好的机会获得正确的解决方案。

这就是随机森林回归器的工作方式：每个决策树都有自己的数据视图，该视图与其他树不同，并且通过将所有预测结合在一起以形成平均值，您很有可能获得良好的结果。

`Automatic` 选项可以尝试自动选择最佳算法。虽然并不总是正确的，可是会帮我们减少对选项的纠结。这里我们就选这个啦。

（5）训练

一切准备就绪后，单击窗口标题栏中的“Train”按钮。几秒钟后（因为我们的数据量还是很小的）会看到一些结果指标。我们关心的值称为“均方根误差”，您应该获得大约180的值。这意味着该模型平均能够预测建议的准确睡眠时间，而误差仅为180秒或三分钟。

（6）输出

在右上角的`Output`可以看到一个 MLModel 图标，文件大小约为438字节。我的是 555 bytes，大概机器和机器之间略有差异。现在模型已经训练完毕，将图标从 Create ML 拖到桌面上，等下回在代码中使用。

**提示：**如果想尝试使用其他算法训练，单击“Create ML”窗口右下角的“Make a Copy”。

## [百日学 Swift（Day 27）](https://www.hackingwithswift.com/100/swiftui/27) – Project 4, part two（项目 4 ：第 2 部分）

### [1. Building a basic layout](https://www.hackingwithswift.com/books/ios-swiftui/building-a-basic-layout)（创建基本布局）

（1）添加输入控件属性

```swift
@State private var wakeUp = Date()          // 计划起床时间
@State private var sleepAmount = 8.0        // 期待睡眠时长
@State private var coffeeAmount = 1         // 每日饮用咖啡数量
```

（2）搭建 UI 骨架

使用下面的代码替换掉默认的 Hello World 文本视图。

```swift
NavigationView {
    VStack {
        // 计划起床时间
        Text("打算几点起床呢？")
        	.font(.headline)
        DatePicker("Please enter a time", selection: $wakeUp, displayedComponents: .hourAndMinute)
        	.labelsHidden()
        // 预期睡眠时长
        Text("想睡多久呢？")
        	.font(.headline)
        Stepper(value: $sleepAmount, in: 4...12, step: 0.25) {
            Text("\(sleepAmount, specifier: "%g") 小时")
        }
        .padding(.horizontal)
        // 每日饮用咖啡杯数
        Text("每天喝几杯咖啡☕️？")
        	.font(.headline)
        Stepper(value: $coffeeAmount, in: 1...20) {
            Text("\(coffeeAmount) 杯")
        }
        .padding(.horizontal)
    }
}
```

（3）创建按钮和调用方法

- 在 ContentView 中增加方法

```swift
func calculateBedtime() {
}
```

- 给 VStack 增加按钮修饰


```swift
.navigationBarItems(trailing:
    Button(action: calculateBedtime) {
        Text("预计就寝时间")
    }
)
```

这样，界面基本上搭建好了，但是按钮调用的方法暂时因为没有代码而不起作用。

### [2. Connecting SwiftUI to Core ML](https://www.hackingwithswift.com/books/ios-swiftui/connecting-swiftui-to-core-ml)（将 SwiftUI 连接到 Core ML）

（1）导入 Core ML 模型到项目

前面通过 Create ML 已经创建好了模型，并通过 Output 输出到 BetterRest.mlmodel 文件。找到这个文件，拖到 Xcode 中的项目文件夹并改名为 SleepCalculator.mlmodel。这样，Xcode 会自动创建一个名为 SleepCalculator 的类。

（2）补充显示信息用的属性

```swift
@State private var alertTitle = ""          // 对话框标题
@State private var alertMessage = ""        // 对话框内容
@State private var showingAlert = false     // 对话框显示状态
```

（3）完成按钮调用方法

```swift
// 按钮调用方法
func calculateBedtime() {
    let model = SleepCalculator()
    let components = Calendar.current.dateComponents([.hour, .minute], from: wakeUp)    // 读取起床时间的时和分
    let hour = (components.hour ?? 0) * 60 * 60     // 将小时换算成秒
    let minute = (components.minute ?? 0) * 60      // 将分钟换算成秒
    do {
        let prediction = try model.prediction(wake: Double(hour + minute), estimatedSleep: sleepAmount, coffee: Double(coffeeAmount))   // 使用模型预测
        let sleepTime = wakeUp - prediction.actualSleep     // 得出就寝时间
        let formatter = DateFormatter()                     // 使用 DateFormatter 转换显示格式
        formatter.timeStyle = .short
        alertTitle = "合理就寝时间是："
        alertMessage = formatter.string(from: sleepTime)
    } catch {
        // 出错处理
        alertTitle = "出错啦！~"
        alertMessage = "很遗憾，程序发生了错误。"
    }
    showingAlert = true		// 无论是否出错，总是显示对话框
}
```

（4）给 VStack 增加 alert 修饰，这样在 calculateBedtime 方法调用结束时，由于 showingAlert 总是设为 true，所以会向用户显示信息。

```swift
.alert(isPresented: $showingAlert) {
    Alert(title: Text(alertTitle), message: Text(alertMessage), dismissButton: .default(Text("好")))
}
```

应该说，程序总体设计告一段落了，下面做一些小的调整。

### [3. Cleaning up the user interface](https://www.hackingwithswift.com/books/ios-swiftui/cleaning-up-the-user-interface)（整理界面）

（1）缩小起床时间的选择范围

绝大多数用户基本上没有夜班需求，所以将起床时间默认设在早上 6 点到 8 点之间会使更多的用户感到方便。可以给添加一个默认起床时间的属性：

```swift
var defaultWakeTime: Date {
    var components = DateComponents()
    components.hour = 7
    components.minute = 0
    return Calendar.current.date(from: components) ?? Date()
}
```

这是个计算属性，使用了 DateComponents 来构建了一个 Date，默认是早上7点，这样就能满足了大部分人需要将起床时间设定为早上 6 点到 8 点之间的需求。然后我们把这个属性作为 wakeUp 的默认值。

```swift
@State private var wakeUp = defaultWakeTime
```

结果会是编译失败，错误是：`Cannot use instance member 'defaultWakeTime' within property initializer;` 这是因为 Swift 不允许这样让一个属性直接使用另一个属性，因为不知道先创建了哪个属性。解决方法是将 defaultWakeTime 设为静态变量，即增加 static 关键字在 var 的前面。

```swift
static var defaultWakeTime: Date {
```

（2）界面调整

首先可以将整个的 VStack 换成 Form，这样使得整个视图成为一个表单，排版比现在这样规整一些。

然后对于每个输入项目有两种方式调整：

- 使用 Section 包裹，去掉 Text 视图，直接在 Section 的 Title 中定义文本（我单独写在了 SectionView.swift 中了）
- 使用 VStack 包裹，设定对齐方式和间距

## [百日学 Swift（Day 28）](https://www.hackingwithswift.com/100/swiftui/28) – Project 4, part three（项目 4 ：第 3 部分）

### 1. 项目盘点

- 新的组件：DatePicker， Stepper，navigationBarItems
- 新的结构体：Date，DateComponents，DateFormatter
- Create ML 和 Core ML
- 不允许属性直接引用属性，如果要引用，需要先设为 static
- 复习练习容器组件和修饰符

> 我发现了个问题，就是在`.alert`修饰器中，对显示的标题或者内容的 Text 加字号修饰貌似无效。

### 2. 挑战

- 去掉按钮，始终显示结果
- 现在这个模型得到的结果是在同样的起床时间预设下，咖啡杯数越多，就寝时间越早……不明白其中的道理。尝试修改模型，研究一下咖啡的作用，即输入期待起床和就寝时间看看和每天饮用咖啡的杯数是啥关系。

## [[百日学 Swift（Day 29）](https://www.hackingwithswift.com/100/swiftui/29) – Project 5, part one（项目 5 ：第 1 部分）

### 1. [Word Scramble: Introduction](https://www.hackingwithswift.com/books/ios-swiftui/word-scramble-introduction)（猜单词项目）

本项目依旧是个小游戏，给玩家一个单词，如 alarming，然后玩家使用单词提供的字母重新组合新的单词，如 ring，mar 等。

我们会应用 List，onAppear()，Bundle，fatalError() 等，然后继续练习前面用过的 @State，Alert，NavigationView 等组件和知识。

现在创建一个新的 Single View App 项目，名字为 WordScramble。到 GitHub 上下载该项目需要的 start.txt 文件。

### 2. [Introducing List, your best friend](https://www.hackingwithswift.com/books/ios-swiftui/introducing-list-your-best-friend)（List 组件）

List 提供可滚动的数据列表，而 Form 实际上是特殊的 List 而已。List 用来展示数据而非输入数据。最常见的写法是：

```swift
List {
    Text("Hello World")
    Text("Hello World")
    Text("Hello World")
}
```

还可以使用循环展示动态内容

```swift
List {
    ForEach(0..<5) {
        Text("Dynamic row \($0)")
    }
}
```

也可以混用

```swift
List {
    Text("Static row 1")
    Text("Static row 2")

    ForEach(0..<5) {
        Text("Dynamic row \($0)")
    }

    Text("Static row 3")
    Text("Static row 4")
}
```

如果再加上分节展示就是

```swift
List {
    Section(header: Text("Section 1")) {
        Text("Static row 1")
        Text("Static row 2")
    }

    Section(header: Text("Section 2")) {
        ForEach(0..<5) {
            Text("Dynamic row \($0)")
        }
    }

    Section(header: Text("Section 3")) {
        Text("Static row 3")
        Text("Static row 4")
    }
}
```

在处理数据是，SwiftUI 需要知道每一行的 id，来保证单独对这行数据进行操作。但对于某个数组而言，每个元素本身就可以成为自己的标识符，从而可以替代 id 的作用。这时候可以使用 `id: \.self`

```swift
List {
    ForEach(people, id: \.self) {
        Text($0)
    }
}
```

### 3. [Loading resources from your app bundle](https://www.hackingwithswift.com/books/ios-swiftui/loading-resources-from-your-app-bundle)（从 app bundle 中获取资源）

使用`Image`视图时，SwiftUI会知道在应用程序的资产目录中查找插图，它甚至会自动调整插图，以便为当前的屏幕分辨率加载正确的图片——这就是我们之前查看的@ 2x和@ 3x内容。

对于其他类型的数据，例如文本文件或具有特定的数据格式（例如XML或JSON）文件类型，则需要另外的方法调用。

Xcode 构建应用时，会创建一个称为`bundle`的东西。 允许系统将一个应用程序的所有文件存储在一个地方，就是我们编写的 Swift 代码编译后的那个二进制代码，所有插图，根据需要提供的任何其他文件，Info.plist文件等等，全部集中在这个地方。

将来，随着技能的提高，我们将学习如何在单个应用程序中实际包含多个捆绑软件，包括Siri 扩展，iMessage应用程序，watchOS 应用程序等内容，所有这些都是在单个 iOS 应用程序捆绑中，称为 main bundle。

在捆绑包中查找其中的文件使用了一种称为`URL`的新数据类型，URL不仅可以存储网址，还可以存储文件的位置。

如果要读取主应用程序捆绑包中文件的 URL，要使用`Bundle.main.url()`。如果该文件存在，则会返回给我们，否则返回`nil`，所以`URL`是可选的。所以需要像这样解包：

```swift
if let fileURL = Bundle.main.url(forResource: "some-file", withExtension: "txt") {
    // we found the file in our bundle!
}
```

应用程序位于沙箱中，所以不应该尝试在其外部读取`URL`里面的内容。

有了URL 后，我们可以使用特殊的初始化程序`String(contentsOf:)`将其加载到字符串中。我们给它一个文件 URL，如果可以加载，它将发送一个包含该文件内容的字符串。如果*无法*加载，则会引发错误，因此需要使用`try`或`try?`类似方式调用它：

```swift
if let fileContents = try? String(contentsOf: fileURL) {
    // we loaded the file into a string!
}
```

一旦有了文件的内容，就可以随心所欲地处理了，因为它只是一个常规字符串。

### 4. [Working with strings](https://www.hackingwithswift.com/books/ios-swiftui/working-with-strings)（使用字符串）

iOS为我们提供了一些功能非常强大的API，用于处理字符串，包括将它们拆分为数组，删除空格甚至检查拼写的能力。

#### （1）拆分字符串为字符串数组：`components(separatedBy:)`方法

在此应用程序中，我们将从应用程序包中加载一个文件，该文件包含10,000多个8个字母的单词，每个单词均可用于启动游戏。这些单词每行存储一个，所以我们真正想要的是将字符串拆分成字符串数组，以便我们可以随机选择一个。

Swift提供了`components(separatedBy:)`方法，可以利用分隔符将单个字符串转换为字符串数组。例如，下面的代码将创建数组`["a1", "b2", "c3"]`：

```swift
let input = "a1 b2 c3"	// 原例子没有数字，但我怕有童鞋会误解为转换成单个字符
let strings = input.components(separatedBy: " ")
```

如果有一个字符串，单词之间用换行符`\n`分隔，因此要将其转换为字符串数组，需要对此进行拆分。

```swift
let input = """
            好雨知时节
            当春乃发生
            随风潜入夜
			润物细无声
            """
let strings = input.components(separatedBy: "\n")
```

无论我们分割了什么字符串，结果都是一个字符串数组。可以通过索引来读取数组中单个值，例如`strings[0]`或`strings[2]`，Swift 还提供了另一个有用的选择：该`randomElement()`方法从数组中返回一个随机项。

如果 letter 是从某个字符串分解得到的字母数组，下面的代码将从数组中读取一个随机字母：

```swift
let letter = letters.randomElement()
```

Swift 并不了解要分解的字符串里面包括什么内容（也许我们试图拆分一个空字符串），所以`randomElement()`方法返回一个可选字符串，我们必须与nil合并解包。

#### （2）删除首尾空白：`trimmingCharacters(in:)`方法

另一个有用的方法是`trimmingCharacters(in:)`，会从字符串的开头和结尾删除某些种类的字符。其中使用了一种称为`CharacterSet`的新类型，但是大多数时候我们想要干的是删除空格和换行符——指的是同时包含空格，制表符和换行符。

由于这太常见了，所以被内置在`CharacterSet`结构中，这样就可以在字符串的开头和结尾处删除所有*空白*，如下所示：

```swift
let trimmed = letter?.trimmingCharacters(in: .whitespacesAndNewlines)
```

#### （3）检查拼写错误：`UITextChecker`类

检查拼写错误的单词的功能通过`UITextChecker`类提供。类名中的“ UI”有两个附加含义：

- 此类来自 UIKit 。但是，这并不意味着正在加载所有旧的用户界面框架。实际上这是通过SwiftUI自动获取的。
- 它是使用 Apple 的较旧语言 Objective-C 编写的。我们不需要编写 Objective-C 来使用它，但是对于Swift用户来说，API有点笨拙。

检查字符串中拼写错误的单词总共需要四个步骤。首先，我们创建一个要检查的单词以及一个可以用来检查该字符串的`UITextChecker`实例：

```swift
let word = "swift"
let checker = UITextChecker()
```

其次，需要告诉检查器要检查多少字符串，是用户选择的文本，还是整个文档。

但是，这里有个陷阱：Swift 使用非常聪明，非常先进的字符串处理方式，从而使其可以使用复杂字符（例如表情符号）的方式与使用英语字母的方式完全相同。然而，Objective-C中并*没有*使用存储字母的这种方法，这意味着我们需要让 Swift 使用所有字符的整个长度去创建一个 Objective-C 字符串范围 `NSRange`：

```swift
let range = NSRange(location: 0, length: word.utf16.count)
```

UTF-16 是所谓的*字符编码* ——一种将字母存储在字符串中的方法。我们在这里使用它，以便 Objective-C 可以了解 Swift 的字符串是如何存储的；对于我们来说，这是一种很好的桥接格式。

第三，我们可以要求文本检查器报告在单词中发现任何拼写错误的地方，传递要检查的范围，在该范围内开始的位置（因此我们可以执行“查找下一个”之类的操作），是否应该换行一旦到达末尾，以及字典使用哪种语言：

```swift
let misspelledRange = checker.rangeOfMisspelledWord(in: word, range: range, startingAt: 0, wrap: false, language: "en")
```

这会返回另一个 NSRange，告诉我们在哪里发现了拼写错误。即使那样，这里仍然存在一个复杂性：Objective-C 没有任何可选概念，因此只能依赖特殊值来表示丢失的数据。如果Objective-C范围返回为空（即，因为字符串正确拼写而没有拼写错误），那么我们将返回特殊值`NSNotFound`。

因此，我们可以检查拼写结果，看是否有这样的错误：

```swift
let allGood = misspelledRange.location == NSNotFound
```

好的，API探索就足够了，让我们进入我们的实际项目…

## [百日学 Swift（Day 30）](https://www.hackingwithswift.com/100/swiftui/30) – Project 5, part two（项目 5 ：第 2 部分）

### [1. Adding to a list of words](https://www.hackingwithswift.com/books/ios-swiftui/adding-to-a-list-of-words)（添加单词到列表）

该应用程序的用户界面将由三个主要的视图组成：一个`NavigationView`显示正在拼写的单词，一个`TextField`可以输入一个答案的位置以及一个`List`显示之前输入的所有单词的视图。

现在，每次用户在文本字段中输入单词时，都会自动将其添加到已用单词列表中。但是，稍后，我们将添加一些验证，以确保该词以前从未使用过，实际上可以从给出的词根中产生，并且是真实词，而不仅仅是一些随机字母。

（1）添加属性

需要一个已经使用过的单词数组，一个根词来为其拼写其他单词，以及一个可以绑定到文本字段的字符串。因此，添加以下三个属性：

```swift
@State private var usedWords = [String]()	// 使用过的单词数组
@State private var rootWord = ""			// 词根
@State private var newWord = ""				// 用户输入的词
```

（2）视图主体

一个`NavigationView`带有`rootWord`标题，然后`VStack`带有一个文本字段和一个列表：

```swift
var body: some View {
    NavigationView {
        VStack {
            TextField("请输入", text: $newWord)

            List(usedWords, id: \.self) {
                Text($0)
            }
        }
        .navigationBarTitle(rootWord)
    }
}
```

通过将`usedWords`直接给到`List`，数组中的每一个词占一行，词语本身就是唯一标识。如果`usedWords`中有很多重复项，会有一些问题，但是很快我们将不允许这样做，所以这不是问题。

（3）修饰 TextField

现在运行程序，在导航栏或列表旁边甚至看不到 TextField。可以通过使用`textFieldStyle()`修饰器在其边缘周围绘制浅灰色边框来解决，再加上一些 `padding()`，看起来就更舒服了些：

```swift
.textFieldStyle(RoundedBorderTextFieldStyle())
.padding()
```

（4）编写添加单词到列表的方法

为了解决这个问题，编写一个新方法`addNewWord()`，该方法将：

- 小写`newWord`并删除所有空格
- 检查它至少有1个字符，否则退出
- 将该单词插入`usedWords`数组中的位置0
- 设置`newWord`为空字符串

稍后，我们将在第2步和第3步之间添加一些额外的验证：

```swift
func addNewWord() {
    // 将单词变为小写，去掉空格
    let answer = newWord.lowercased().trimmingCharacters(in: .whitespacesAndNewlines)

    // 如果是空字符串就退出
    guard answer.count > 0 else {
        return
    }

    // 待编写的校验单词的代码

    // 将输入的单词加入的数组第一个，保证在列表的第一行显示
    usedWords.insert(answer, at: 0)
    // 清空输入框
    newWord = ""
}
```

（5）调用 addNewWord 方法

如果想在用户按下键盘上的return时调用`addNewWord()`，可以通过为文本字段提供*on commit*闭包来实现。这是个尾随闭包。由于闭包的签名（它需要接受的参数及其返回类型）与`addNewWord()`方法完全匹配，因此我们可以直接将其传递：

```swift
TextField("Enter your word", text: $newWord, onCommit: addNewWord)
```

现在运行程序，可以在文本字段中键入单词，按回车键，然后看到它们出现在列表中。

（6）修改 TextField 修饰

`addNewWord()`中会将用户输入的单词转换为小写和去掉空格，这意味着用户不能添加"`" car"`，`"Car"`和`"CAR"`。但是，该文本字段会自动将用户键入的首字母大写，因此，当输入`"Car"`时，他们在列表中看到的是`"car"`。

为了解决这个问题，可以在 TextField 上使用另一个修饰器禁用文本字段的大写`autocapitalization()`：

```swift
.autocapitalization(.none)
```

（7）添加单词长度

SF Symbols 提供从0到50的圆圈数字，所有数字均使用“ x.circle.fill”格式命名，如`1.circle.fill`，`20.circle.fill`。可以用来显示文本旁边每个单词的长度。

如果在`List`的行内使用第二个视图，SwiftUI 将自动创建一个隐式水平堆栈，以便该行中的所有内容并排放置。所以直接在列表中添加`Image(systemName:)`就可以了：

```swift
List(usedWords, id: \.self) {
    Image(systemName: "\($0.count).circle")
    Text($0)
}
```

如果现在运行该应用程序，将会看到可以在文本字段中键入单词，按回车键，然后看到它们滑入列表，并且其长度图标在侧面。真挺好！

### [2. Running code when our app launches](https://www.hackingwithswift.com/books/ios-swiftui/running-code-when-our-app-launches)（启动应用时运行代码）

（1）准备单词表

Xcode 构建 iOS 项目时，会将编译后的程序，Info.plist 文件，资产目录和任何其他资产放入一个名为*bundle*的目录中，然后为该捆绑包命名为 YourAppName.app 。iOS 和Apple 的其他平台会自动识别此“`.app`扩展名，因此，如果在 macOS 上双击类似Notes.app 之类的文件，系统知道要在捆绑软件中启动该程序。

项目中包含一个名为“ start.txt”的文件，里面有10,000多个八个字母的单词，这些单词将随机选择供玩家使用。该文件可以从 GitHub下载，下载后将start.txt拖入项目中。

（2）编写游戏启动方法 startGame()

我们已经定义了一个名为`rootWord`的属性，其中将包含玩家所使用的进行拼写的单词。现在需要编写一个新方法`startGame()`，该方法将：

- 在捆绑包中找到start.txt
- 加载到字符串中
- 将该字符串拆分为字符串数组，每个元素为一个单词
- 从那里选择一个随机词分配给`rootWord`，如果数组为空，则使用明智的默认值。

每一个任务都对应于一行代码，但是有一个不同之处：如果无法在应用程序包中找到start.txt，或者可以*找到*但无法*加载*它，该怎么办？在这种情况下，会遇到一个严重的问题，因为应用程序确实坏了，比如忘记了以某种方式包含文件（在这种情况下游戏无法正常工作），或者包含了该文件，但由于某些原因 iOS 拒绝读取（在这种情况下，游戏将无法正常工作，并且应用程序也已损坏）。

对于这些问题，最好是能立即终止并给出问题的原因，而不是让应用程序始终处于崩溃状态。Swift 提供了一个名为`fatalError()`的函数，该函数可以使我们真正清楚地发现问题。当调用`fatalError()`时，总是会*无条件导致应用程序崩溃*。这对我们来说很重要，看一下代码和注释：

```swift
func startGame() {
    // 在应用的 bundle 中找到 start.txt 的 URL
    if let startWordsURL = Bundle.main.url(forResource: "start", withExtension: "txt") {
        // 2. 将 start.txt 赋值给字符串变量 startWords
        if let startWords = try? String(contentsOf: startWordsURL) {
            // 3. 使用换行符将字符串变量分割为字符串数组
            let allWords = startWords.components(separatedBy: "\n")

            // 4. 随机选择一个元素作为词根，默认为 nothing
            rootWord = allWords.randomElement() ?? "nothing"

            // 如果所有一切都正常，就返回（退出方法）
            return
        }
    }

    // 如果发生了问题，调用 fatalError 函数
    fatalError("Could not load start.txt from bundle.")
}
```

（3）调用 startGame()

现在，我们有了一种为游戏加载所有内容的方法，我们需要在显示视图时实际调用该东西。

SwiftUI为我们提供了一个专用的视图修饰器 onAppear，用于在显示视图时运行闭包，可以在`navigationBarTitle()`后面添加此修饰器它来调用`startGame()`：

```swift
.onAppear(perform: startGame)
```

现在运行游戏，则应该在导航视图的顶部看到一个随机的八个字母的单词。但是玩家仍然可以输入任何单词，包括和词根无关的。让我们接下来修复该问题...

### [3. Validating words with UITextChecker](https://www.hackingwithswift.com/books/ios-swiftui/validating-words-with-uitextchecker)（使用 UITextChecker 检查单词）

现在需要确保用户不能输入无效的单词。我们将以四种小方法实现，每种方法仅执行一次检查：

- 输入的单词是第一次输入
- 输入的单词的字母组合来源于词根（不可能从 nothing 中输入 car）
- 输入的单词是个真实的词

呃，这明明只有*三种*方法——这是因为第四个方法将使显示错误消息更加容易。

（1）isOriginal 方法

好吧，让我们从第一个方法开始：它将接受一个字符串作为其唯一参数，并根据该单词是否被使用过而返回 true 或 false。我们已经有了一个`usedWords`数组，因此我们可以将单词传递给数组的`contains()`方法并将结果发送回：

```swift
func isOriginal(word: String) -> Bool {
    !usedWords.contains(word)
}
```

搞定一个了！

（2）isPossible 方法

下一个比较棘手：如何检查是否可以从另一个随机单词的字母中选出一个随机单词？

有两种方法可以解决此问题，但最简单的方法是：如果创建根单词的可变副本，则可以循环遍历用户输入单词的每个字母，以查看该字母是否存在于副本中。如果是这样，将其从副本中删除（因此不能再次使用），然后继续。如果整个循环都没有遇到找不到的问题，说明该单词就是从词根里面来的，而一旦遇到就返回false。

因此，这是我们的第二个方法：

```swift
func isPossible(word: String) -> Bool {
    var tempWord = rootWord		// 复制词根
	// 遍历输入的单词
    for letter in word {
        if let pos = tempWord.firstIndex(of: letter) {
            // 如果字母在词根中找到，在词根中移除掉这个字母
            tempWord.remove(at: pos)
        } else {
            // 如果没找到，返回 false
            return false
        }
    }

    return true
}
```

（3）isReal 方法

最终的方法比较难，因为我们需要使用 UIKit 中的`UITextChecker`。为了将Swift字符串安全地桥接到 Objective-C 字符串，需要创建一个使用 UTF-16 计数的 Swift 字符串`NSRange`实例。看起来这比较麻烦，但是恐怕在 Apple 清理好这些API之前这是不可避免的。

因此，我们的最后一个方法将创建`UITextChecker`实例，该实例负责扫描字符串中拼写错误的单词。再创建一个`NSRange`来扫描字符串的整个长度，然后文本检查器调用`rangeOfMisspelledWord()`查找错误的单词，会返回*另一个* `NSRange`告诉我们在哪里找到了拼写错误的单词，但是如果单词正确，则该范围的位置将是特殊值`NSNotFound`。代码如下：

```swift
func isReal(word: String) -> Bool {
    let checker = UITextChecker()
    let range = NSRange(location: 0, length: word.utf16.count)
    let misspelledRange = checker.rangeOfMisspelledWord(in: word, range: range, startingAt: 0, wrap: false, language: "en")

    return misspelledRange.location == NSNotFound
}
```

（4）第 4 个方法：wordError

在使用这三个功能之前，可以添加几个属性来控制错误警报的内容：

```swift
@State private var errorTitle = ""
@State private var errorMessage = ""
@State private var showingError = false
```

现在，可以添加一个方法，根据接收到的参数设置标题和消息，然后将`showingError`布尔值翻转为 true：

```swift
func wordError(title: String, message: String) {
    errorTitle = title
    errorMessage = message
    showingError = true
}
```

然后，我们可以通过在`alert()`下面添加一个修饰器将它们直接传递给 `.onAppear()`：

```swift
.alert(isPresented: $showingError) {
    Alert(title: Text(errorTitle), message: Text(errorMessage), dismissButton: .default(Text("好")))
}
```

（5）在`addNewWord()`中用以下内容替换`// 待编写的校验单词的代码`注释：

```swift
guard isOriginal(word: answer) else {
    wordError(title: "这个单词已经输入过了", message: "请输入一个没用过的单词")
    return
}

guard isPossible(word: answer) else {
    let title = String("这个单词不是从 \(rootWord) 来的")
    let message = String("只能在 \(rootWord) 中选择字母，每个字母只能选择一次")
    wordError(title: title, message: message)
    return
}

guard isReal(word: answer) else {
    wordError(title: "输入的单词没有意义", message: "请输入拼写正确的单词")
    return
}
```

如果现在运行程序，会发现尝试重复的单词，无法从根词中拼出的单词和乱七八糟的词都不起作用了。

## [百日学 Swift（Day 31）](https://www.hackingwithswift.com/100/swiftui/31) – Project 5, part three（项目 5 ：第 3 部分）

### 1. 项目盘点

- List 组件
- onAppear 修饰器
- Bundle 的概念和 fatalError() 的应用
- UITextChecker、NSRange 的使用

### 2. 挑战

- 输入单词长度应该大于等于 3
- 增加游戏开始按钮
- 增加得分（猜中单词数量），在不同的分数给不同的警告。
- 增加规则说明

> 项目的源码可以到 [GitHub](https://github.com/HH-Ge/100DaysOfSwift/tree/master/Projects/D29-31.WordScramble) 上查看。

## [[百日学 Swift（Day 32）](https://www.hackingwithswift.com/100/swiftui/32) – Project 6, part one（项目 6 ：第 1 部分）

### [1. Animation: Introduction](https://www.hackingwithswift.com/books/ios-swiftui/animation-introduction)（项目介绍）

本项目研究的是动画和过渡。先创建项目吧，项目名称 Animations。本节内容因为是介绍和动画相关的语法，所以内容叙述上较为分散。

### [2. Creating implicit animations](https://www.hackingwithswift.com/books/ios-swiftui/creating-implicit-animations)（创建隐式动画）

（1）先随便弄个按钮出来。

```swift
Button("点我") {
    // 先空着
}
.padding(50)				// 数字会决定按钮的大小
.background(Color.red)		// 背景色，
.foregroundColor(.white)	// 前景色，
.clipShape(Circle())		// 圆形，为了后面的演示
// 这些修饰的具体内容可以随便你高兴去具体设定
```

（2）增加动画状态属性

```swift
@State private var animationAmount: CGFloat = 1
```

这里应该注意的是，因为涉及与旧的 API 交互，所以要使用一种称为 CGFloat 的数据类型，它和 Double 很像，但是比 Double 存储的数值范围要小一些。这是考虑到较老的硬件的兼容性。使用 CGFloat 可以让程序忽略具体的硬件。不过现在越来越多的硬件都支持 Double 了。

> **Swift 没有办法自动推断出 CGFloat 类型，所以必须要显式声明。**

（3）给按钮增加缩放效果

给按钮增加下面的修饰

```swift
.scaleEffect(animationAmount)
```

scaleEffect 修饰是以给定的数字改变视图的尺寸（水平和垂直同步修改，同时和锚点关联）。数字的含义如下

- 符号：正数，原始样子；负数，上下翻转
- 绝对值：大于 1，放大；0 ~ 1，缩小；0：消失

（4）增加按钮动作

在按钮的动作响应代码中，添加下面的代码

```swift
self.animationAmount += 1
```

这样每次点击按钮时，按钮就变大一些。因为不会以新的尺寸重新渲染，所以会变得有点模糊。

（5）增加动画

给按钮增加 animation 修饰

```swift
.animation(.default)
```

这样，我们能看到变大的过程是平缓的，不是直接切换的。现在是默认效果。

（6）增加模糊效果

给按钮增加模糊修饰 blur，其中的参数表示模糊半径，最小为 0（不模糊），负数无意义。

```swift
.blur(radius: (animationAmount - 1) * 3)
```

现在放大和模糊的效果会在点击按钮后同时出现了。我们没有告诉程序关于动画的任何细节（起止时间，关键帧等），但是已经可以看见动画了。

### [3. Customizing animations in SwiftUI](https://www.hackingwithswift.com/books/ios-swiftui/customizing-animations-in-swiftui)（在 SwiftUI 中自定义动画）

本段内容，我觉得课程仍然使用那个圆形按钮，效果不明显，所以我改成了方块的水平运动（这里有个 offset 修饰可能是没介绍过，这个修饰使用的数据类型也是 CGFloat）

（1）动画形式

刚才使用的 `.animation(.default)`是默认动画，实际上是“缓入缓出”动画，即 easeInOut，类似的还有 easeIn，easeOut。还有弹簧动画：

```swift
.animation(.interpolatingSpring(stiffness: 50, damping: 1))
```

刚度 stiffness 会影响动画的初始速度，阻尼 damping 会影响来回弹跳的时间。具体还需要大家自己测试摸索。

（2）时间控制

持续时间 duration 和延迟 delay，数值都是 Double，单位是秒

（3）重复动画

```swift
.repeatCount(3, autoreverses: true)		// 有限重复，数字是重复次数，autoreverses是否复位
.repeatForever(autoreverses: true)		// 无限重复
```

下面是 CustomAnimation 的主体部分

```swift
struct CustomAnimation: View {
    @State private var animationAmount: CGFloat = 1
    @State private var offsetAmount: CGFloat = 0
    var body: some View {
        VStack{
            HStack {
                RoundedRectangle(cornerRadius: 10)
                .frame(width: 60, height: 40)
                .foregroundColor(.blue)
                .offset(x: offsetAmount)
                .animation(
                    Animation.easeInOut(duration: 2)        // 动画形式和持续时间
                    .delay(1)                               // 延迟时间
                    .repeatCount(2, autoreverses: true)     // 重复次数，是否复位
                    .repeatForever(autoreverses: false)     // 连续动画
                )
                .onAppear{
                    self.offsetAmount = 280
                }
            }
            .padding(.horizontal, 15)
            .frame(maxWidth: .infinity, alignment: .leading)
            .frame(height: 100)
            .background(Color(.gray))    
            // 后面还有三个 HStack，分别注释了 delay 并修改了动画形式
        }
    }
}
```

（4）一个有脉动效果的按钮

使用 overlay 修饰，在按钮上覆盖一个圆形。在圆形上使用stroke修饰进行描边，使用 scaleEffect 和 opacity 修饰缩放比例和透明度并使之随 animationAmount 数值改变而改变，使用 animation 修饰定义动画并在动画上使用 repeatForever 修饰重复动画，就得到了一个有脉动效果的按钮。

```swift
Button("点我") {
    // self.animationAmount += 1
}
.padding(40)
.background(Color.red)
.foregroundColor(.white)
.clipShape(Circle())
.overlay(
    Circle()
        .stroke(Color.red)
        .scaleEffect(animationAmount)
        .opacity(Double(2 - animationAmount))
        .animation(
            Animation.easeOut(duration: 1)
                .repeatForever(autoreverses: false)
        )
)
.onAppear {
    self.animationAmount = 2
}
```

### [4. Animating bindings](https://www.hackingwithswift.com/books/ios-swiftui/animating-bindings)（动画绑定）

对于修饰器参数，感觉除去布尔值，几乎所有值的变化都可以制作动画。先看下面的代码

```swift
struct ContentView: View {
    @State private var animationAmount: CGFloat = 1

    var body: some View {
        VStack {
            Stepper("缩放系数（1~10）：\(animationAmount, specifier:"%g")", 
                    value: $animationAmount.animation(), in: 1...10)
                .padding()

            Spacer()

            Button("点我") {
                self.animationAmount += 1
            }
            .padding(40)
            .background(Color.red)
            .foregroundColor(.white)
            .clipShape(Circle())
            .scaleEffect(animationAmount)
        }
    }
}
```

其中的 Stepper 就是绑定了 $animationAmount.animation() ，所以点击加减按钮的时候会有动画变化。而按钮只是通过在点击时改变 animationAmount 的值来影响 scaleEffect 修饰去改变按钮的缩放，并未定义值变化的动画，所以没有动画显示。 

绑定在 Stepper 上的动画就是隐式动画，绑定动画同样可以使用动画修饰器，如动画形式、时长、延迟、重复什么的。绑定动画不是在视图上设定动画和通过状态变量显式定义如何动画。显式动画中的状态变量不知道触发了动画，绑定动画则是视图不知道自己会动画。二者皆有效，二者皆重要。

***大叔的小实验***

下面的代码是测试两个按钮通过切换 布尔值 状态，分别利用透明度和缩放比例来控制控件是否显示，状态的切换使用动画。实验中发现 CGFloat 从 0 到 1 程序不执行了，改成 0.0001 或者更小（反正能保证看不见就行）就没事了。

```swift
@State private var show1 = false
var title1: String {
    return show1 ? "解散" : "集合"
}
var opacity1: Double {
    return show1 ? 1 : 0
}

@State private var show2 = false
var title2: String {
    return show2 ? "解散" : "集合"
}
var scale2: CGFloat {
    return show2 ? 1 : 0.00001		// 设成 0 程序就停住了，我猜是 CGFloat 的事情
}

var body: some View {
    VStack {
        HStack {
            Button(action: {
                self.show1.toggle()
            }) {
                Text(title1)
        	}

            RoundedRectangle(cornerRadius: 10)
            .frame(width: 60, height: 40)
            .foregroundColor(.blue)
            .opacity(opacity1)
            .animation(Animation.easeInOut(duration: 1))
        }
        
        HStack {
            Button(action: {
                self.show2.toggle()
            }) {
                Text(title2)
            }

            RoundedRectangle(cornerRadius: 10)
            .frame(width: 60, height: 40)
            .foregroundColor(.green)
            .scaleEffect(scale2)
            .animation(Animation.easeInOut(duration: 1))
        }    
    }.padding()
}
```

### [5. Creating explicit animations](https://www.hackingwithswift.com/books/ios-swiftui/creating-explicit-animations)（创建显式动画）

前面已经了解了 SwiftUI 如何通过将`animation()`修饰符附加到视图来创建*隐式动画*，以及如何通过将`animation()`修饰符添加到绑定来创建*动画的绑定更改*，但是还有第三种方式可以创建动画：在状态发生改变后，显式地让 SwiftUI 产生动画变化。 

我们仍然不必手动创建动画的每一帧，那是 SwiftUI 的活儿，它通过状态更改前后查看视图的状态持续地找出动画。

但是，现在，我们明确地希望在状态发生任意改变时发生动画：它没有附加到绑定，也没有附加到视图，只是我们明确要求发生特定的动画，因为状态变化。

为了说明这一点，让我们再次回到简单的按钮示例：

```swift
struct ContentView: View {   
    var body: some View {
        Button("点我") {
            // 点击后的动作
        }
        .padding(50)
        .background(Color.red)
        .foregroundColor(.white)
        .clipShape(Circle())
    }
}
```

现在要在点击该按钮后，让按钮带有3D效果旋转。这需要另一个新的修饰器，`rotation3DEffect()`可以为其指定以度为单位的旋转量以及确定视图旋转方式的轴。共有三个维度的轴：

- X轴（水平）：可以想象成屏幕的上边，考虑原点的话，或许就先想成上沿，左边是0。
- Y轴（垂直）：可以想象成屏幕的左边。上面是 0。
- Z轴（深度）：即通过左上角做屏幕的垂线，屏幕的上层是正数。

首先需要一个可以修改的某些状态，并且旋转度指定为`Double`。

```swift
@State private var animationAmount = 0.0 	// 除去 Int 外，我觉得应该尽量显式声明类型
```

接下来，让按钮`animationAmount`沿其 Y 轴旋转：

```swift
.rotation3DEffect(.degrees(animationAmount), axis: (x: 0, y: 1, z: 0))
```

现在是重要部分：在按钮的动作中添加一些代码，以便在`animationAmount`每次点击时将其添加360 。

如果只写`self.animationAmount += 360`，那么更改将立即发生，因为按钮上没有附加动画修改器。这是显式动画出现的方式。如果使用`withAnimation()`闭包，那么SwiftUI将确保由新状态引起的任何更改都将自动进行动画处理。

因此，现在将其放入按钮的操作中：

```swift
withAnimation {
    self.animationAmount += 360
}
```

现在运行，每次点击按钮，它就会在3D空间中旋转。可以自己尝试一下其他轴或者多个轴。

`withAnimation()`同样可以使用可以在SwiftUI中其他位置使用的所有相同动画作为动画参数。例如，

```swift
withAnimation(.interpolatingSpring(stiffness: 5, damping: 1)) {
    self.animationAmount += 360
}
```

这样就使用上了弹簧动画。

## [百日学 Swift（Day 33）](https://www.hackingwithswift.com/100/swiftui/33) – Project 6, part two（项目 6 ：第 2 部分）

### [1. Controlling the animation stack](https://www.hackingwithswift.com/books/ios-swiftui/controlling-the-animation-stack)（控制动画堆栈）

***大叔注：***这个标题有些……直译的误导。视图后面的修饰器排列起来就像一个*堆栈*。动画堆栈实际上是说在修饰器*堆栈*里面多次使用动画修饰。

先看下面的代码，这两段代码说明了修饰器的顺序如何重要。

```swift
Button("Tap Me") {
    // do nothing
}
.background(Color.blue)
.frame(width: 200, height: 200)
.foregroundColor(.white)
```

```swift
Button("Tap Me") {
    // do nothing
}
.frame(width: 200, height: 200)    
.background(Color.blue)
.foregroundColor(.white)
```

其中的道理前面有讲，而且我们还反复使用`background()`和`padding()`创造一个条纹边框效果。

这就是概念一：修饰符顺序很重要，因为SwiftUI用修饰符按应用顺序包裹视图。

概念二是我们可以`animation()`对视图应用修饰符，以使其隐含地对更改进行动画处理。

为了演示这一点，我们可以修改按钮代码，以便根据某些状态显示不同的颜色。首先，我们定义状态：

```swift
struct CustomViewModifier: View {
    @State var show = false			// 定义状态
    var body: some View {
        VStack(spacing: 15) {
            
            Button("点我变色"){
                self.show.toggle()	// 状态切换
            }
            .frame(width: 200, height: 100, alignment: .center)
            .foregroundColor(.white)
            .background(Color(show ? .red : .blue))		// 颜色切换
            .animation(.default)						// 动画
        }
    }
}
```

运行代码，将看到点击按钮会在蓝色和红色之间为其设置动画的颜色。

现在给按钮增加一个圆角修饰器，

对。保护自己，因为这可能会受伤。

```swift
Button("点我变色，圆角没有动画"){
    self.show.toggle()	// 状态切换
}
.frame(width: 200, height: 200)
.background(show ? Color.blue : Color.red)
.animation(.default)
.foregroundColor(.white)
.clipShape(RoundedRectangle(cornerRadius: show ? 60 : 0))
```

运行后会看到点击按钮会使其在红色和蓝色之间进行动画处理，但是在正方形和圆角矩形之间的切换*不会进行*动画处理。

如果将`clipShape()`修改器移到动画之前，如下所示：

```swift
Button("点我变色和圆角都有动画") {
    self.enabled.toggle()
}
.frame(width: 200, height: 200)
.background(enabled ? Color.blue : Color.red)
.foregroundColor(.white)
.clipShape(RoundedRectangle(cornerRadius: enabled ? 60 : 0))
.animation(.default)
```

运行代码时，背景颜色和剪辑形状都将进行动画处理。再次说明顺序很重要：`animation()`仅影响在它之前发生的更改。

如果应用多个`animation()`修改器，则每个修改器控制着之前动画处理过的所有内容。这样能够以各种不同的方式为状态变化设置动画，而不是为所有属性统一设置。

例如，可以使用默认动画来进行颜色更改，但是对剪辑形状使用插值弹簧：

```swift
Button("点我变色和圆角有不同动画") {
    self.enabled.toggle()
}
.frame(width: 200, height: 200)
.background(enabled ? Color.blue : Color.red)
.animation(.default)
.foregroundColor(.white)
.clipShape(RoundedRectangle(cornerRadius: enabled ? 60 : 0))
.animation(.interpolatingSpring(stiffness: 10, damping: 1))
```

为了获得更多控制，可以通过传递`nil`到修饰器来完全禁用动画。如果需要立即进行颜色更改，但剪辑形状保留其动画，可以这样编写：

```swift
Button("点我变色无动画，圆角有动画") {
    self.enabled.toggle()
}
.frame(width: 200, height: 200)
.background(enabled ? Color.blue : Color.red)
.animation(nil)
.foregroundColor(.white)
.clipShape(RoundedRectangle(cornerRadius: enabled ? 60 : 0))
.animation(.interpolatingSpring(stiffness: 10, damping: 1))
```

### [2. Animating gestures](https://www.hackingwithswift.com/books/ios-swiftui/animating-gestures)（动画手势）

SwiftUI 允许将手势附加到任何视图，并且这些手势的效果也可以动画。稍后，我们将更详细地介绍手势，但现在让我们尝试一些相对简单的操作：可以在屏幕上拖动的卡片，但是放开后，它会卡回到其原始位置。

首先，我们的初始布局：

```swift
struct ContentView: View {
    var body: some View {
        LinearGradient(
            gradient: Gradient(colors: [.yellow, .red]), 
            startPoint: .topLeading, 
            endPoint: .bottomTrailing
        )
            .frame(width: 300, height: 200)
            .clipShape(RoundedRectangle(cornerRadius: 10))
    }
}
```

这样可以在屏幕中央绘制类似卡片的视图。我们想根据手指的位置在屏幕上移动它，这需要三个步骤。

首先，我们需要某种状态来存储其拖动量：

```swift
@State private var dragAmount = CGSize.zero
```

其次，我们要使用该大小来影响卡在屏幕上的位置。SwiftUI为此提供了一个专用的修饰符`offset()`，它使我们能够调整视图的 X 和 Y 坐标而无需在其周围移动其他视图。您可以根据需要输入离散的 X 和 Y 坐标，但是-绝非偶然- `offset()`也可以`CGSize`直接采用。

因此，第二步是将此修改器添加到线性渐变中：

```swift
.offset(dragAmount)
```

现在重要的部分到了：我们可以创建一个`DragGesture`并将其附加到卡上。在这里我们对拖动手势有用的两个额外的修饰符：移动时运行的`onChanged()` 和结束拖动时运行的`onEnded()`。

它们都有一个参数，描述了拖动操作——它的开始位置，当前位置，移动距离等等。对于`onChanged()`修改器，我们将读取拖动的*位移*，该*位移*告诉我们拖动距起点有多远——可以直接将其赋值给`dragAmount`以便视图随手势一起移动。对于`onEnded()`要完全忽略输入，因为需要将设置`dragAmount`复位。

因此，现在将此修饰符添加到线性渐变中：

```swift
.gesture(
    DragGesture()
        .onChanged { self.dragAmount = $0.translation }
        .onEnded { _ in self.dragAmount = .zero }
)
```

如果运行代码，您会看到现在可以拖动渐变卡了，放开拖动时，它将跳回到中心。卡的偏移量由`dragAmount`确定，该偏移量又由拖动手势设置。

现在一切正常，我们可以通过一些动画使该动作栩栩如生，我们有两个选择：添加一个隐式动画以使拖动*和*释放具有动画效果，或者添加一个显式动画以使释放成为动画。

要查看前者的实际效果，请将此修改器添加到线性渐变中：

```swift
.animation(.spring())
```

拖动时，由于弹簧动画的作用，卡会稍有延迟地移到拖动位置，但是如果突然移动，它也会轻轻地过冲。

要看到*明确的*动画在行动，删除`animation()`修改和改变现有的`onEnded()`拖拽手势的代码如下：

```swift
.onEnded { _ in
    withAnimation(.spring()) {
        self.dragAmount = .zero
    }
}
```

现在，这张卡将立即跟随您的拖动（因为没有被动画化），但是当您放开它时，*它将进行*动画处理。

如果我们将偏移动画与拖动手势并稍加延迟相结合，则无需大量代码就可以创建非常有趣的动画。

为了证明这一点，我们可以将文本“ Hello SwiftUI”编写为一系列单独的字母，每个字母的背景颜色和偏移量都由某个状态控制。使用`Array("Hello SwiftUI")`可以得到一个字符串数组：每个元素是一个字符。

```swift
struct ContentView: View {
    let letters = Array("Hello SwiftUI")
    @State private var enabled = false
    @State private var dragAmount = CGSize.zero

    var body: some View {
        HStack(spacing: 0) {
            ForEach(0..<letters.count) { num in
                Text(String(self.letters[num]))
                    .padding(5)
                    .font(.title)
                    .background(self.enabled ? Color.blue : Color.red)
                    .offset(self.dragAmount)
                    .animation(Animation.default.delay(Double(num) / 20))
            }
        }
        .gesture(
            DragGesture()
                .onChanged { self.dragAmount = $0.translation }
                .onEnded { _ in
                    self.dragAmount = .zero
                    self.enabled.toggle()
                }
        )
    }
}
```

如果运行该代码，您会发现可以拖动任意字母以使整个字符串都跟随该字符串，只是短暂的延迟会导致类似蛇的效果。当您释放拖动时，SwiftUI还将添加颜色更改，即使字母移回中心也可以在蓝色和红色之间进行动画显示。

### [3. Showing and hiding views with transitions](https://www.hackingwithswift.com/books/ios-swiftui/showing-and-hiding-views-with-transitions)（使用过渡显示或隐藏视图）

SwiftUI最强大的功能之一是能够自定义视图的显示和隐藏方式。之前，您已经了解了如何使用常规`if`条件有条件地包含视图，这意味着当条件发生变化时，我们可以从视图层次结构中插入或删除视图。

过渡控制插入和删除的方式，我们可以使用内置过渡，以不同方式组合它们，甚至创建完全自定义的过渡。

为了说明这一点，这里有一个`VStack`带有按钮和一个矩形的：

```swift
struct ContentView: View {
    var body: some View {
        VStack {
            Button("Tap Me") {
                // do nothing
            }

            Rectangle()
                .fill(Color.red)
                .frame(width: 200, height: 200)
        }
    }
}
```

我们可以使矩形仅在满足特定条件时显示。首先，我们添加一些可以操纵的状态：

```swift
@State private var isShowingRed = false
```

接下来，我们将该状态用作显示矩形的条件：

```swift
if isShowingRed {
    Rectangle()
        .fill(Color.red)
        .frame(width: 200, height: 200)
}
```

最后，我们可以`isShowingRed`在按钮的操作中在true和false之间切换：

```swift
self.isShowingRed.toggle()
```

如果运行该程序，则会看到按下按钮会显示并隐藏红色方块。没有动画。它只是出现而突然消失。

我们可以使用来包装状态更改`withAnimation()`，从而获得SwiftUI的默认视图过渡，如下所示：

```swift
withAnimation {
    self.isShowingRed.toggle()
}
```

有了较小的更改，应用程序现在就可以淡入和淡出红色矩形，同时还可以向上移动按钮以腾出空间。看起来不错，但我们可以使用`transition()`修饰符做得更好。

例如，我们可以通过在矩形上添加`transition()`修饰符来使矩形放大和缩小：

```swift
Rectangle()
    .fill(Color.red)
    .frame(width: 200, height: 200)
    .transition(.scale)
```

现在点击按钮看起来更好：矩形会随着按钮的腾出而扩大，然后再次点击时会缩小。

如果要尝试，还可以尝试其他几种转换。一个有用的是`.asymmetric`，它使我们可以在显示视图时使用一个过渡，而在消失时使用另一个过渡。要进行尝试，请使用以下命令替换矩形的现有过渡：

```swift
.transition(.asymmetric(insertion: .scale, removal: .opacity))
```

### [4. Building custom transitions using ViewModifier](https://www.hackingwithswift.com/books/ios-swiftui/building-custom-transitions-using-viewmodifier)（使用 ViewModifier 创建自定义过渡）

   为SwiftUI创建全新的过渡是可能的，而且实际上出乎意料的容易，这使我们可以使用完全自定义的动画添加和删除视图。

`.modifier`过渡使此功能成为可能，该过渡接受我们想要的任何视图修饰符。要注意的是，我们需要能够实例化修饰符，这意味着它必须是我们自己创建的修饰符。

为了尝试这一点，我们可以编写一个视图修改器，让我们模仿Keynote中的Pivot动画-它使新幻灯片从其左上角旋转入。用SwiftUI讲，这意味着创建一个视图修改器，使我们的视图从一个角旋转，而不会逃脱它应该位于的边界。SwiftUI实际上为我们提供了修改器来做到这一点：`rotationEffect()`让我们在2D空间中旋转视图，并`clipped()`阻止将视图绘制到其矩形空间的外部。

`rotationEffect()`与相似`rotation3DEffect()`，但它始终绕Z轴旋转。但是，它也使我们能够控制旋转的*锚点* -视图的哪一部分应固定在旋转中心。SwiftUI为我们提供了一个`UnitPoint`用于控制锚，它可以让我们指定确切的X / Y点的许多内置选项旋转或使用一个类型- ，`.topLeading`，`.bottomTrailing`，`.center`等等。

让我们通过创建一个`CornerRotateModifier`结构来构造所有代码，这些结构具有一个锚点来控制旋转的位置，并控制一个旋转量：

```swift
struct CornerRotateModifier: ViewModifier {
    let amount: Double
    let anchor: UnitPoint

    func body(content: Content) -> some View {
        content.rotationEffect(.degrees(amount), anchor: anchor).clipped()
    }
}
```

`clipped()`那里的添加意味着当视图旋转时，不会绘制位于其自然矩形之外的零件。

我们可以使用`.modifier`过渡直接尝试一下，但这有点笨拙。一个*更好的*主意是将其包装到的扩展中`AnyTransition`，使它在其最前端的角从-90旋转到0：

```swift
extension AnyTransition {
    static var pivot: AnyTransition {
        .modifier(
            active: CornerRotateModifier(amount: -90, anchor: .topLeading),
            identity: CornerRotateModifier(amount: 0, anchor: .topLeading)
        )
    }
}
```

有了这个，我们现在可以使用以下方法将透视动画附加到任何视图：

```swift
.transition(.pivot)
```

（大叔注：说实话，3 和 4 的实验效果不理想）

## [百日学 Swift（Day 34）](https://www.hackingwithswift.com/100/swiftui/34) – Project 6, part three（项目 6 ：第 3 部分）

### 1. 项目盘点

- CGFloat，一种类似 Double 的数据类型，兼容旧的 API 和设备，必须显式声明类型。
- animation 修饰器用来定义动画的形式，如 easeIn，easeOut，easeInOut 等，duration 参数定义动画时长。
- 隐式动画，动画绑定，显式动画
- 动画修饰器：relay 延迟，repeatCount 重复次数，repeatForever 永不停歇
- 拖动手势：DragGesture
- 修饰器：overlay，stroke，scaleEffect，rotation3DEffect，gesture
- UITextChecker、NSRange 、withAnimation 的使用

### 2. 挑战

返回到 Guess the Flag 项目并添加一些动画：

1. 当点击正确的标志时，使其在 Y 轴上旋转360度。
2. 使其他两个按钮淡出至 25％ 的不透明度。
3. 如果您点击了错误的标志？好吧，这取决于您–发挥创意！

> 项目的源码可以到 [GitHub](https://github.com/HH-Ge/100DaysOfSwift/tree/master/Projects/D29-31.WordScramble) 上查看。

## [百日学 Swift（Day 35）](https://www.hackingwithswift.com/100/swiftui/35) – Milestone: Projects 4-6（第 3 阶段总结，挑战）

### 1. 学习内容

- 如何使用来从用户读取数字`Stepper`，包括在标签为简单文本视图时使用其较短的格式。
- 让用户使用来输入日期`DatePicker`，包括使用`displayedComponents`参数来控制日期或时间。
- 在斯威夫特日期合作，使用`Date`，`DateComponents`和`DateFormatter`
- 如何引入机器学习以利用现代iOS设备的全部功能。
- 使用构造数据的滚动表`List`，特别是如何直接从数据数组创建行。
- 使用显示视图时运行代码`onAppear()`。
- 通过使用`Bundle`类查找文件路径来从我们的应用程序包中读取文件，包括从那里加载字符串。
- 使用破坏您的代码`fatalError()`，以及为什么这实际上可能是一件好事。
- 如何使用检查字符串是否正确拼写`UITextChecker`。
- 使用`animation()`修饰符隐式创建动画。
- 自定义具有延迟和重复的动画，并在“缓入”动画和“春季”动画之间进行选择。
- 将`animation()`修饰符附加到绑定，以便我们可以直接从UI控件制作动画。
- 使用`withAnimation()`创建明确的动画。
- 将多个`animation()`修改器附加到单个视图，以便我们可以控制动画堆栈。
- 使用`DragGesture()`让各地用户举动的看法，然后捕捉他们回到原来的位置。
- 使用SwiftUI的内置过渡，并创建自己的过渡。

### 2. 知识要点

- #### 具有ForEach和List的范围

正如我已经说过几次，当我们在一个循环中创建视图时，SwiftUI需要了解如何唯一地标识每个项目，以便它可以对来回的数据进行动画处理。这本身并不复杂，但是有一种特殊的用法会把人们拒之门外，这就是*range*。

首先，让我们看一些代码：

```swift
ForEach(0..<5) {
    Text("Row \($0)")
}
```

从0到5循环播放，每次打印出一些文本。SwiftUI可以确保每个项目都是唯一的，因为它在一个范围内计数，并且范围没有重复的值。

实际上，如果您查看我们背后的SwiftUI代码，`ForEach`您会发现它实际上是这样的：

```swift
public init(_ data: Range<Int>, @ViewBuilder content: @escaping (Int) -> Content)
```

视图生成器（实际上是构成视图的东西）将从范围中获得一个整数，并有望发送回一些可以呈现的视图内容。

现在尝试编写以下代码：

```swift
ForEach(0...5) {
   Text("Row \($0)")
}
```

从0 *到* 5 计数，这意味着它将创建六个视图。或至少它*会*创建六个视图（如果它确实起作用的话）–该代码无法编译。

再看一下`ForEach`想要的数据类型：`Range`。那是一个整数范围，但这是一个非常特定的范围–还有另一个非常相似的类型称为`ClosedRange`，这就是导致问题的原因。

当我们写的时候`0..<5`我们得到一个`Range`，但是当我们写的时候`0...5`我们得到一个`ClosedRange`。尽管它看起来与我们相似，但Swift认为这两个范围类型是不同的，因此我们不能将其与封闭范围一起使用`ForEach`-目前尚不可能，尽管我希望这会改变。

- #### 什么使弦乐？

从我们的角度来看，很容易将字符串想象为一件相当琐碎的事情：有一个字母，然后是另一个字母，然后是第三个，第四个字母，依此类推，也许还有一些标点符号分散在其中。但是实际上，字符串是Swift中一些最复杂的功能，值得花一点时间来了解正在发生的事情。

首先，您可能已经注意到不允许这样的代码：

```swift
let name = "Paul"
let firstLetter = name[0]
```

试图读取字符串“ Paul”的第一个字母。如果我们要求一个人“运行”该代码，他们会说“ P”，这很有意义，因为这是第一个字母。

但是，实际上，字符串比单个字母复杂得多：许多表情符号是由多个字符组成的，它们背靠背描述它们所包含的内容。例如，简单的竖起大拇指表情符号具有多种肤色，这可以通过基本表情符号（竖起大拇指）然后通过肤色修饰符（从浅到深）实现。最终是多个单独的字符，但我们看到一个字符：具有特定颜色的竖起表情符号。

如果Swift单独对待这些字符，则阅读第一个字母将读取没有表情的竖起表情符号，而阅读第二个字母将读取没有竖起的表情色–前者可以接受，但不完全符合发送者的预期，而后者会很奇怪。

现在考虑这样的代码：

```swift
print(name.count)
```

这将打印出测试字符串中有多少个字符，这再次看起来很容易。但是，正如我们已经看到的，实际上应该将某些单个字符组合在一起以创建组合的含义，这意味着`count`不能只返回字符串中有多少个字符。取而代之的是，它需要从第一个字母开始，并计算每个唯一的字母（考虑到所有连接在一起的修饰符）才能得出总数。

这不是很快，但是可以保证是正确的。如果没有别的，那就是我希望您摆脱的字符串：有时它们可能会有些棘手，但是Swift代表我们做了很多工作，以确保我们不会偶然出错。这的确意味着在使用简单字符串时会从我们那里获取更多代码，但这也意味着将来我们会自动获得对高级字符串（包括您能想到的任何表情符号）的支持。

- #### 平板应用捆绑

在Word Scramble中，我们在包中查找了start.txt，然后将其加载以供游戏使用。然后我解释说，所有iOS，macOS，tvOS和watchOS应用程序都作为捆绑包出售，这些捆绑包将其二进制文件（已编译的Swift程序），其Info.plist，其资产目录等结合在一起。

我*没有*提到的一件事是这些捆绑包的构建方式，尤其是我想提及资产目录和松散文件。

首先，资产目录是我们一直在存储要在应用程序中使用的图像的位置，它们不仅仅是一种组织图片的理想方式。实际上，当Xcode构建我们的资产目录时，它会遍历我们所有的图片并针对iOS设备对其进行优化，然后将结果放入可以有效加载的已编译资产目录中。随着资产目录的进一步发展，您将了解到它们可以处理矢量资产，颜色，纹理等等，它们是多用途的东西！

其次，松散资产用于我们应用程序中的所有*其他*类型的媒体–文本文件，JSON，XML，电影等。如果您有很多这样的文件，则可以在Xcode内进行分组以组织它们，但是在构建时，一切都消失了：所有这些文件都放入一个称为*资源目录的目录中*。发生这种情况的原因是，当我们要求捆绑包查找“ start.txt”的URL时，它不需要搜索应用捆绑包中的所有目录，而是可以在一个位置查找，因为所有文件都在那里。

这会产生一个有趣的问题，这是您早晚会遇到的问题：由于Xcode项目中所有地方的所有松散文件最终都放置在一个资源目录中，因此您无法在任何地方两次使用相同的资产文件名在您的项目中。不管文件位于哪个组中，或者它们在Xcode项目中看起来有多远都没有关系：如果您的项目中有两个名为start.txt的文件，则构建将失败，因为Xcode无法将它们都放入同一目录

### 3. 挑战

您的目标是为孩子们构建一个“娱乐”应用程序，以帮助他们练习乘法表–“什么是7 x 8？” 等等。娱乐应用程序的代码具有教育意义，但理想情况下，它们应具有足够的趣味性，以使孩子们喜欢玩。

分解：

- 玩家需要选择他们想要练习的乘法表。这可以是按按钮，也可以是“最多...”步进，从1到12。
- 玩家应该能够选择要问多少个问题：5、10、20或“全部”。
- 您应该在他们要求的难度范围内随机产生他们所要求的问题。对于“全部”情况，应生成所有可能的组合。

如果您想完全沿着“教育”路线走下去，那将是一些步进器，一个文本字段和几个按钮。我建议这是一个不错的起点，只是要确保您已经掌握了基础知识。

一旦有了这些，就`Stepper`取决于您要将应用程序带入“娱乐”路线的程度了–您可以完全放弃固定控件，如果需要的话，可以依靠彩色按钮来获得相同的结果。您可以使用[Kenney的Animal Pack](https://kenney.nl/assets/animal-pack-redux)（顺便说一下，这是公共领域！）之类的东西来添加有趣的主题，以使其成为真实的游戏。希望您还会在顶部添加一些动画–它需要吸引9岁及以下的孩子，因此变得明亮，色彩丰富，甚至有点滑稽是一个好主意！

为了解决这一挑战，您需要利用到目前为止在所有项目中学到的技能，但是，如果您从小处着手，并朝着前进的方向努力，那么您将获得最大的成功机会。从本质上讲，它不是一个复杂的应用程序，因此请掌握正确的基础知识并仅在有时间的时候进行扩展。

至少，您应该：

1. 首先从Single View App模板开始，然后添加一些状态以确定游戏是否处于活动状态或您是否要求设置。
2. 由于该应用程序具有两种截然不同的状态-“我们正在要求用户进行设置”和“游戏正在运行”-您应使用a `Group`作为您的顶级视图，以便`some View`始终将相同的视图类型发送回去。
3. 尝试将布局分解为新的SwiftUI视图，而不是将所有内容放入中`ContentView`。
4. 向玩家显示他们在游戏结束时正确回答了多少个问题，然后提出让他们再次玩。

我将在下面提供一些提示，但我建议您在阅读之前尝试尽可能多的挑战。

提示：

- 您应该在游戏开始时立即生成所有问题，并将其存储为一系列问题。
- 这些问题可能应该是他们自己的Swift结构`Question`，用于存储文本和答案。
- 提出问题时，请使用另一个名为的状态属性`currentQuestion`，它是指向问题数组中某个位置的整数。
- 您可以使用屏幕上的按钮（如计算器）或使用数字键盘文本字段（无论您喜欢哪个）来获得用户输入。





